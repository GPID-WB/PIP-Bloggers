{
  "hash": "cbb7efa45b32454cd21a80a7d08af811",
  "result": {
    "markdown": "---\ntitle: \"Collapse Cheat sheet\"\ndescription: \"Syntax translation from dplyr and data.tablen to collapse\"\nauthor: \"PIP Technical team\"\ndate: \"03/13/2025\"\ncategories: [collapse, data.table, dplyr, efficiency]\nformat:\n  html:\n    toc: true\neditor_options: \n  chunk_output_type: console\nexecute:\n  output: false\n---\n\n\n## Introduction\n\nThis post is inspired in the Atreba's blog: [A data.table and dplyr tour](https://atrebas.github.io/post/2019-03-03-datatable-dplyr/). The objective of this post is to complement Atreba's one with the syntax of the [`{collapse}`](https://sebkrantz.github.io/collapse/) R package.\n\n## Basic understanding of the three packages\n\n### dplyr\n\nA grammar of data manipulation in R which provides a consistent set of verbs to help you solve the most common data manipulation challenges. It is part of the `tidyverse` universe. [Click here for more information.](https://dplyr.tidyverse.org/).\n\n### data.table\n\nA syntax to operate data manipulation operations, such as subset, group, update, join, etc. It reduces programming and compute time tremendously. [Click here for more information.](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html)\n\n### collapse\n\nA large C/C++ based package for data transformation and statistical computing in R. It aims to facilitate complex data transformations, explorations and computing tasks in R, while making code fast, flexible, parsimonious and programmer friendly. [Click here for more information.](https://sebkrantz.github.io/collapse/)\n\n## Load libraries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(data.table)\nlibrary(collapse)\nlibrary(tidyverse)\n```\n:::\n\n\n## Data\n\n\n::: {.cell hash='index_cache/html/data_5d221bd57edb88902e47cf113999f84d'}\n\n```{.r .cell-code}\nset.seed(42)\n\n# Number of rows\nn <- 10000\n\n# # Generate fake data\n# df <- data.frame(\n#   id1 = 1:n,  # Unique ID\n#   id2 = sample(1:500, n, replace = TRUE),  # Repeating ID\n#   dt = seq.Date(from = as.Date(\"2023-01-01\"), by = \"day\", length.out = n),  # Dates\n#   tm = format(seq.POSIXt(from = as.POSIXct(\"2023-01-01 00:00:00\"), \n#                          by = \"hour\", length.out = n), \"%H:%M:%S\"),  # Time\n#   ch = sample(c(\"A\", \"B\", \"C\", \"D\"), n, replace = TRUE),  # Character\n#   int = sample(1:100, n, replace = TRUE),  # Integer\n#   log = sample(c(TRUE, FALSE), n, replace = TRUE),  # Logical\n#   realf = runif(n, 1, 100),  # Real (float),\n#   reald = runif(n),  # Real ,\n#   fct = factor(sample(c(\"X\", \"Y\", \"Z\"), n, replace = TRUE))  # Factor\n# )\n\nset.seed(42)\n\n# Number of rows\nn <- 10000\n\n# Generate fake data with some NAs\ndf <- data.frame(\n  id1 = 1:n,  # Unique ID\n  id2 = sample(1:500, n, replace = TRUE),  # Repeating ID\n  dt = sample(c(seq.Date(from = as.Date(\"2023-01-01\"), by = \"day\", length.out = n), NA), n, replace = TRUE),  # Dates with NAs\n  tm = sample(c(format(seq.POSIXt(from = as.POSIXct(\"2023-01-01 00:00:00\"), \n                                  by = \"hour\", length.out = n), \"%H:%M:%S\"), NA), n, replace = TRUE),  # Time with NAs\n  ch = sample(c(\"A\", \"B\", \"C\", \"D\", NA), n, replace = TRUE, prob = c(0.24, 0.24, 0.24, 0.24, 0.04)),  # Character with some NAs\n  int = sample(c(1:100, NA), n, replace = TRUE),  # Integer with some NAs\n  log = sample(c(TRUE, FALSE, NA), n, replace = TRUE, prob = c(0.49, 0.49, 0.02)),  # Logical with some NAs\n  realf = sample(c(runif(n, 1, 100), NA), n, replace = TRUE),  # Real (float) with some NAs\n  reald = sample(c(runif(n), NA), n, replace = TRUE),  # Real with some NAs\n  fct = factor(sample(c(\"X\", \"Y\", \"Z\", NA), n, replace = TRUE, prob = c(0.32, 0.32, 0.32, 0.04)))  # Factor with some NAs\n)\n\n# Print summary to check distribution of NAs\nsummary(df)\n\n\n# Ensure uniqueness\ndf <- unique(df, by = c(\"id1\", \"id2\"))\ndt <- copy(setDT(df))\ntb <- as_tibble(df)\n```\n:::\n\n\n## Basic use\n\n### Filtering rows\n\n#### Filter rows using indices\n\n::: panel-tabset\n## collapse\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# super efficient\ndf |> \n  ss(2:5)\n\n# efficient\ndf |> \n  fsubset(2:5)\n```\n:::\n\n\n## data.table\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[2:5]\n```\n:::\n\n\n## dplyr\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntb |> \n  slice(2:5)\n\n# or using index like any data.frame\ntb[2:5,]\n\n# you need to add the comma. Otherwise, you get a different result\ntb[2:5]\n```\n:::\n\n:::\n\n#### Discard rows using negative indices\n\n::: panel-tabset\n## collapse\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  ss(-c(2:5)) |> \n  head(4)\n\ndf |> \n  ss(-c(2:5)) |> \n  head(4)\n```\n:::\n\n\n## data.table\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[!2:5] |> \n  head(4)\n```\n:::\n\n\n## dplyr\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntb |> \n  slice(-(2:5)) |> \n  head(4)\n```\n:::\n\n:::\n\n#### Filter rows using conditions\n\n::: panel-tabset\n\n::: {.cell}\n\n```{.r .cell-code}\n# using named objects to filter data\nch  <- \"A\" # data has this as variable name\nfct <- \"A\" # data has this as variable name\nx  <- \"A\"\n```\n:::\n\n\n## collapse\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  fsubset(ch == \"A\" & id1 == 6)\n\ndf |> \n  fsubset(ch == x & id1 == 6)\n\n# This works\ndf |> \n  fsubset(ch == ch & id1 == 6)\n\n# This does not work\ndf |> \n  fsubset(ch == fct & id1 == 6)\n\n# This through error\ndf |> \n  fsubset(ch == get(fct) & id1 == 6) |> \n  try()\n\n# This works\ndf |> \n  fsubset(ch == get(\"fct\", envir = -2) & id1 == 6) \n\n# NOTE: is there a better way?\n```\n:::\n\n\n## data.table\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[ch == \"A\" & id1 == 6]\n\ndt[ch == x & id1 == 6]\n\ndt[ch ==ch & id1 == 6]\n\n# this does not work\ndt[ch == fct & id1 == 6]\n\n\ndt[ch == eval(fct) & id1 == 6]\n\n# These work but they are  verbose\ndt[ch == get(\"fct\", envir = parent.frame()) & id1 == 6]\ndt[ch == get(\"fct\", envir = -2) & id1 == 6]\n```\n:::\n\n\n## dplyr\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntb |> \n  filter(ch == \"A\" & id1 == 6)\n\ntb |> \n  filter(ch == x & id1 == 6)\n\ntb |> \n  filter(ch == ch & id1 == 6)\n\n# does not work\ntb |> \n  filter(ch == fct & id1 == 6)\n\n# works really well\ntb |> \n  filter(ch == !!fct & id1 == 6)\n```\n:::\n\n:::\n\n#### Filter unique rows\n\n::: panel-tabset\n\n::: {.cell}\n\n```{.r .cell-code}\n# Removing duplicate rows based on the values of one or more columns \n```\n:::\n\n\n## collapse\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Remove duplicate rows\ndf |>\n  funique()\n\n# Keeps only one row per unique value in id2\ndf |>\n  funique(cols = \"int\") # selecting column by col name \ndf |>\n  funique(cols = 6)     # selecting column by indices\ndf |>\n  funique(cols = names(df) %in% \"int\") # with logical condition\n```\n:::\n\n\n## data.table\n\n\n::: {.cell}\n\n```{.r .cell-code}\n # Remove duplicate rows\ndt |>\n  unique()\n\n# Keeps only one row per unique value in id2\ndt |>\n  unique(by = \"id2\")  \n```\n:::\n\n\n## dplyr\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Remove duplicate rows\ntb |>\n  distinct()\n\n# Keeps only one row per unique id1\ntb |> distinct(id1, .keep_all = TRUE) # keep all col\n```\n:::\n\n:::\n\n#### Discard rows with missing values\n\n::: panel-tabset\n## collapse\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Discard rows with any NA value\ndf |>\n  na_omit()\n\n# Discard rows with NA value for selected col\ndf |>\n  na_omit(cols = \"ch\")\n\n# More flexible options:\n# Remove rows where more than 50% of values are missing\ndf |>\n  na_omit(prop = 0.5)\n```\n:::\n\n\n## data.table\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Discard rows with any NA value\ndt |>\n  na_omit()\n\n# Discard rows with NA value for selected col\ndt <- dt[!is.na(ch)]\n```\n:::\n\n\n## tidyverse\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Discard rows with any NA value\ntb |>\n  tidyr::drop_na()\n\n# Discard rows with NA value for selected col\ntb |> \n  tidyr::drop_na(ch)\n```\n:::\n\n:::\n\n#### Other filters: slice options\n\n::: panel-tabset\n## collapse\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  fslice(n = 3)                 # First 3 rows\ndf |>\n  fslice(n   = 3, \n         how = \"last\")          # Last 3 rows\ndf |>\n  fslice(n = 0.1)               # Fraction of rows: first 10% of rows\n\nfslice(n        = 3, \n       how      = \"min\", \n       order.by = int)          # 3 obs with lowest int\n\n# TODO: add fslicev()\n```\n:::\n\n\n## data.table\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Frist 3 rows\ndt[1:3, ]   # First 3 rows, all columns\n\n\n# Last 3 rows\ndt[(.N-2):.N]  # .N gives the total number of rows\n\n# Fraction of rows: first 10% of rows\ndt[1:(.N * 0.1)]\n\n\n# 3 obs with lowest int\ndt[order(int)][1:3]\n```\n:::\n\n\n## dplyr\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# First 3 rows\ntb |>\n  slice_head(n = 3)\n\n# Last 3 rows\ntb |>\n  slice_tail(n = 3)\n\n# Fraction of rows: first 10% of rows\ntb |>\n  slice_head(prop = 0.1)\n\n# 3 obs with lowest int\ntb |>\n  slice_min(order_by = int, \n            n        = 3) # all rows\n\ntb |>\n slice_min(order_by = int, \n           n        = 3, \n           with_ties = FALSE) \n```\n:::\n\n:::\n\n### Sort rows\n\n#### Sort rows by column(s)\n\n::: panel-tabset\n## collapse\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  roworder(id1)  \n\ndf |>\n  roworder(-id2)      # Sort by decreasing order of id2\n\ndf |>\n  roworder(id1, -id2) # Sort by multiple cols \n```\n:::\n\n\n## data.table\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[order(id2)]    # This makes a copy\n\nsetorder(dt, id2) # To modify by reference  \n\ndt[order(-id2)]   # Sort by decreasing order\n\ndt[order(id1, -id2)] # Sort by multiple cols \n```\n:::\n\n\n## dplyr\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntb |>\n  arrange(id2)\n\ntb |>\n  arrange(desc(id2)) # Sort by decreasing order\n\n# Sort by multiple cols \ndf |>\n   arrange(id1, desc(id2))\n```\n:::\n\n:::\n\n### Select columns\n\n#### Select one or more columns\n\n::: panel-tabset\n\n::: {.cell}\n\n```{.r .cell-code}\n# select one column using an index, not recommended, or column name\n# select multiple columns \n```\n:::\n\n\n## collapse\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Select one column   ####\n# _________________________ \n\n# by index\ndf |>\n  fselect(2)\n\ndf |>\n  slt(2) # shorthand for fselect\n\n# by name\n\ndf |>\n  fselect(id2)  # returns a dataframe \n\n## Select multiple columns ####\n# _____________________________ \n\ndf |>\n  fselect(id1, id2, fct)\n\ndf |>\n  fselect(id1, ch:fct)\n```\n:::\n\n\n## data.table\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Select one column   ####\n# _________________________ \n\n# by index\ndt[[3]]  # returns a vector\ndt[, 3]  # returns a data.table\n\n# by name\ndt[, list(id2)] # returns a data.table\ndt[, .(id2)]    # returns a data.table (. is an alias for list)\ndt[, \"id2\"]     # returns a data.table\ndt[, id2]       # returns a vector\ndt[[\"id2\"]]     # returns a vector\n\n## Select multiple columns ####\n# _____________________________ \n\ndt[, .(id1, id2, int)]\ndt[, list(id1, id2, int)]\ndt[, id2:int] # select columns between id2 and int\n```\n:::\n\n\n## dplyr\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Select one column   ####\n# _________________________ \n\ntb |>\n  select(id2)               # returns a tibble\n\npull(tb, id2, name = ch)    # returns a (named) vector\ntb[, \"id2\"]                 # returns a tibble\ntb[[\"id2\"]]                 # returns a vector\n\n## Select multiple columns ####\n# _____________________________ \n\ndf |>\n  select(id1, id2, ch)\ndf |>\n  select(id1, ch:fct)\n```\n:::\n\n:::\n\n#### Exclude columns\n\n::: panel-tabset\n## collapse\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exclude columns by column names \ndf |>\n  fselect(-dt, -tm)\n\n# Using a character vector \ncols <- c(\"dt\", \"tm\")\n\ndf |>\n  fselect(-cols)  # does not work \n```\n\n::: {.cell-output .cell-output-error}\n```\nError in -cols: invalid argument to unary operator\n```\n:::\n\n```{.r .cell-code}\ndf |>\n  fselect(!cols) # does not work \n```\n\n::: {.cell-output .cell-output-error}\n```\nError in !cols: invalid argument type\n```\n:::\n\n```{.r .cell-code}\n# what is a better way to do this?\n```\n:::\n\n\n## data.table\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exclude columns by column names \ndt[, !c(\"dt\", \"tm\")]\n\n# Using a character vector \ncols <- c(\"dt\", \"tm\")\n\ndt[, ..cols] \n# .. prefix means 'one-level up', as cols is outside the parent environment \n\ndt[, !..cols] # or dt[, -..cols]\n```\n:::\n\n\n## dplyr\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exclude columns by column names \ntb |>\n  select( -dt, -tm)\n\n# Using a character vector \ncols <- c(\"dt\", \"tm\")\n\ntb |>\n  select(all_of(cols))\n\ntb |>\n  select(-all_of(cols))\n```\n:::\n\n:::\n\n#### Other selections - not sure it is relevant, to check\n\n### Miscellaneous\n\n#### Read & write data\n\n##### Write\n\n::: panel-tabset\n## collapse\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# no specific functions for reading and writing data \n```\n:::\n\n\n## data.table\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfwrite(dt, \n       \"DT.csv\")                # write to csv\n\n\nfwrite(dt, \n       \"DT.txt\", \n       sep = \"\\t\")              # write to a tab-delimited file\n```\n:::\n\n\n## dplyr\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::write_csv(tb, \n                 \"tb.csv\")  # write to csv\n\nreadr::write_delim(tb, \n                   \"tb.txt\", \n                   delim = \"\\t\")  # write to a tab-delimited file\n```\n:::\n\n:::\n\n##### Read\n\n::: panel-tabset\n## collapse\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# no specific functions for reading and writing data \n```\n:::\n\n\n## data.table\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfread(\"dt.csv\")   # read csv\n# fread(\"DT.csv\", verbose = TRUE) # full details\n\nfread(\"dt.txt\", sep = \"\\t\") # read tab-delimited file\n\n# Read and rbind several files\nrbindlist(\n  lapply(c(\"dt.csv\", \"dt.csv\"), \n         fread))\n```\n:::\n\n\n## dplyr\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::read_csv(\"tb.csv\")  # read csv\n\nreadr::read_delim(\"tb.txt\", \n                  delim = \"\\t\")  # read tab-delimited file\n\n# Read and rbind several files\nc(\"tb.csv\",  \"tb.csv\") |>\n  purrr::map_dfr(readr::read_csv)\n```\n:::\n\n:::\n\n#### Reshape data\n\n::: panel-tabset\n## collapse\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ---- Long to Wide ----\nwide_pivot <- pivot(df, \n                    ids    = c(\"id1\", \"id2\", \"dt\"),  # Columns to keep\n                    values = \"int\",              # Column with values\n                    names  = \"ch\",   # Column whose values become new cols\n                    how    = \"wider\")               # Reshape to wide format\n\n# ---- Wide to Long ----\nlong_pivot <- pivot(wide_pivot, \n                    ids    = c(\"id1\", \"id2\", \"dt\"),  \n                    values = NULL,  \n                    names  = list(\"ch\", \"int\"),  \n                    how    = \"longer\")     \n```\n:::\n\n\n## data.table\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ---- Long to Wide ----\nwide_dt <- dcast(dt, \n                 id1 + id2 + dt ~ ch, \n                 value.var = \"int\")\n\n# ---- Wide to Long ----\nlong_dt <- melt(wide_dt, \n                id.vars       = c(\"id1\", \"id2\", \"dt\"), \n                variable.name = \"ch\", \n                value.name    = \"int\")\n```\n:::\n\n\n## dplyr\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ---- Long to Wide ----\ntb_wide <- tb |>\n  # rm NAs\n  filter(!is.na(ch)) |>\n  pivot_wider(names_from  = ch, \n              values_from = int)\n\n# ---- Wide to Long ----\ntb_long <- tb_wide |>\n  pivot_longer(cols      = c(\"A\", \"D\", \"C\", \"B\"),\n               values_to = \"int\",\n               names_to  = \"ch\")\n```\n:::\n\n:::\n\n### Summarise data\n\n#### Summarise columns\n\n::: panel-tabset\n## collapse\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# efficient\ndf |>\n  fsummarise(sum_rf = fsum(realf),\n             sd_rd = fsd(reald))\n\n# shorthand\ndf |>\n  smr(sum_rf = fsum(realf),\n      sd_rd = fsd(reald))\n```\n:::\n\n\n## data.table\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[, sum(realf)] # returns a vector\n\ndt[, .(sum(realf))] # returns a data.table\n\ndt[, .(sum_rf = sum(realf), # returns a data.table with named columns\n       sd_rd = sd(reald))]\n```\n:::\n\n\n## dplyr\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(tb, sum(realf)) # returns a tibble\n\ntb |> \n  summarise(sum_rf = sum(realf), # returns a tibble\n            sd_rd = sd(reald))\n```\n:::\n\n:::\n\n#### Helper functions\n\n::: panel-tabset\n## collapse\n\nThe package includes `fsum`,`fprod`, `fmedian`, `fmode`, `fvar`, `fsd`, `fmin`,`fmax`,`fnth`, `ffirst`, `flast`,`fnobs`, and `fndistinct`.\n\n## data.table\n\nThe package includes `first`, `last` and `uniqueN`.\n\n## dplyr\n\nThe package includes `first`, `last`, `n`, `nth`, and `n_distinct`.\n:::\n\n### Manipulations of columns\n\n::: panel-tabset\n## collapse\n\n\n::: {.cell}\n\n```{.r .cell-code}\n # Add one oe several columns (can also use ftransform)\ndf <- df |>\n  fmutate(log_rf = log(realf)) \n\ndf <- df |>\n  fmutate(log_rd = log(reald),\n           sqrt_rd = sqrt(reald))\n\n# Create one column and eliminate others\nfcompute(df, log2_rf = log_rf*2) \n\n # remove columns\ndf <- df |>\n  fselect(-log_rf,-log_rd,-sqrt_rd)\n```\n:::\n\n\n## data.table\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add one column\ndt[, log_rf := log(realf)] \n\n# Add several columns\ndt[, ':=' (log_rd = log(reald), \n           sqrt_rd = sqrt(reald))]\n\n# Create one column and eliminate others\ndt[, .(log2_rf = log_rf*2)] \n\n# remove columns\ndt[, c(\"log_rf\", \"log_rd\", \"sqrt_rd\") := NULL] \n```\n:::\n\n\n## dplyr\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add one or several column\ntb <- tb |> \n  mutate(log_rf = log(realf))\n\ntb <- tb |> \n  mutate(log_rd = log(reald), \n           sqrt_rd = sqrt(reald))\n\n# Create one column and eliminate others\ntransmute(tb, log2_rf = log_rf*2)\n\n# remove columns\ntb <- tb |> \n  select(-log_rf,-log_rd,-sqrt_rd)\n```\n:::\n\n:::\n\n### by\n\n::: panel-tabset\n## collapse\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  fgroup_by(ch)|>\n  fsummarise(sumrf = fsum(realf)) # ordered and indexed results\n\n# Assigned column name\n\ndf |> \n  fgroup_by(abc = tolower(ch))|>\n  fsummarise(sumrf = fsum(realf))\n\n# Add a column with number of observations for each group\n\ndf |>\n  fgroup_by(ch)|>\n  fcount(add = TRUE)\n```\n:::\n\n\n## data.table\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[, .(sumrf = sum(realf)), by = \"ch\"] # unordered results\n\n# Reordered and indented:\n\ndt[, keyby = ch,\n     .(sumrf = sum(realf))]\n\n# Assigning column name\n\ndt[, keyby = .(abc = tolower(ch)),\n     .(sumrf = sum(realf))]\n\n# Add a column with number of observations for each group\n\ndt[, n := .N, by = ch][]\ndt[, n := NULL] # remove for consistency\n```\n:::\n\n\n## dplyr\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntb |> \n  group_by(ch)|>\n  summarise(sumrf = sum(realf)) # ordered results\n\n# Assigned column name\n\ntb |> \n  group_by(abc = tolower(ch))|>\n  summarise(sumrf = sum(realf))\n\n# Add a column with number of observations for each group\n\ntb |>\n  group_by(ch)|>\n  add_tally()\n\n# or...\n\nadd_count(tb, ch)\n```\n:::\n\n:::\n\n## Going further\n\n### Advanced columns manipulation\n\n::: panel-tabset\n## collapse\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Summarize columns\ndf |>\n  fsummarise(across(c(\"realf\", \"reald\"),\n            fmean))\n\n# Summarize using a condition\ndf |>\n  fsummarise(across(is.numeric, # different from dplyr due to across\n                   fmean))\n\n# Modify all the columns\ndf |> \n  fmutate(across(NULL,rev))\n\n# Modify several columns\ndf |> \n  fcomputev(vars = c(\"realf\", \"reald\"), # dropping the other columns\n                  sqrt)\n\ndf <- df |>\n  ftransformv(vars = c(\"realf\", \"reald\"), # keeping the other columns\n                sqrt)\n\ndf <- df |>\n  ftransformv(vars = c(\"realf\", \"reald\"), # reverting for consistency\n                FUN = function(x){ x^2 })\n\n# Modify columns using a condition \n\ndf |>\n  fcomputev(is.numeric,\n           FUN = function(x){x - 1})\n```\n:::\n\n\n## data.table\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Summarize columns\ndt[, lapply(.SD, mean),\n   .SDcols = c(\"realf\", \"reald\")]\n\n# Summarize using a condition\ndt[, lapply(.SD, mean),\n     .SDcols = is.numeric]\n\n# Modify all the columns\ndt[, lapply(.SD, rev)]\n\n# Modify several columns\ndt[, lapply(.SD, sqrt), # dropping the other columns\n     .SDcols = realf:reald]\n\ncols <- c(\"realf\", \"reald\")\n\ndt[, (cols) := lapply(.SD, sqrt), # keeping the other columns\n     .SDcols = cols]\n\ndt[, (cols) := lapply(.SD, \"^\", 2L), # reverting for consistency\n     .SDcols = cols]\n\n# Modify columns using a condition \ndt[, .SD - 1,\n     .SDcols = is.numeric] \n\nrm(cols)\n```\n:::\n\n\n## dplyr\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Summarize columns\ntb |>\n  summarise(across(c(\"realf\", \"reald\"),\n            mean))\n\n# Summarize using a condition\ntb |>\n  summarise(across(where(is.numeric),\n                   mean))\n\n# Modify all the columns\ntb |> \n  mutate(across(everything(),\n                rev))\n\n# Modify several columns\ntb |>\n  transmute(across(c(\"realf\", \"reald\"), # dropping the other columns\n                  sqrt))\n\ntb <- tb |>\n  mutate(across(all_of(c(\"realf\", \"reald\")), # keeping the other columns\n                sqrt))\n\ntb <- tb |>\n  mutate(across(all_of(c(\"realf\", \"reald\")), # reverting for consistency\n                ~ \"^\"(.x, 2L)))\n\n# Modify columns using a condition \n\ntb |>\n  transmute(across(where(is.numeric), \n                   ~ '-'(., 1L)))\n```\n:::\n\n:::\n\n### Chain expressions\n\n::: panel-tabset\n## collapse\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  fgroup_by(ch)|>\n  fsummarise(sumrf = fsum(realf))|>\n  fsubset(sumrf < 129000)\n```\n:::\n\n\n## data.table\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[, by = ch,\n   .(sumrf = sum(realf))][\n     sumrf < 129000\n   ]\n```\n:::\n\n\n## dplyr\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntb |>\n  group_by(ch)|>\n  summarise(sumrf = sum(realf))|>\n  filter(sumrf < 129000)\n```\n:::\n\n:::\n\n### Indexing and keys (not sure it applies)\n\n### set modifications\n\n::: panel-tabset\n## collapse\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Replace values (recommendation to use set of data.table)\n\nset(df, i = 1L, j = 2L, value = 30L) \n\n# Reorder rows\n\ndf <- roworder(df, id2, -id1)\n\ndf <- roworder(df, id1) # reversal for consistency\n\n# Modify column names\n\ndf <- frename(df, dt = date)\n\ndf <- frename(df, date = dt) # reversal for consistency\n\n# reorder columns\n\ndf <- colorder(df, id1, id2, ch)\n```\n:::\n\n\n## data.table\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Replace values\n\nset(dt, i = 1L, j = 2L, value = 30L)\n\n# Reorder rows\n\nsetorder(dt, id2, -id1)\n\nsetorder(dt, id1) # reversal for consistency\n\n# Modify column names\n\nsetnames(dt, old = \"dt\", new = \"date\")\n\nsetnames(dt, old = \"date\", new = \"dt\")  # reversal for consistency\n\n# reorder columns\n\nsetcolorder(dt, c(\"id1\",\"id2\",\"ch\"))\n```\n:::\n\n\n## dplyr\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Replace values\n\ntb[1,2] <- 30L\n\n# Reorder rows\n\ntb <- arrange(tb, id2, desc(id1))\n\ntb <- arrange(tb, id1) # reversal for consistency\n\n# Modify column names\n\ntb <- rename(tb, date = dt)\n\ntb <- rename(tb, dt = date) # reversal for consistency\n\n# reorder columns\n\ntb <- relocate(tb, c(\"id1\", \"id2\", \"ch\"))\n```\n:::\n\n:::\n\n### Advanced use of by (maybe)\n\n## Join/Bind data sets\n\n### Bind\n\n::: panel-tabset\n## collapse\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- data.table(1:3)\ny <- data.table(4:6)\nz <- data.table(7:9, 0L)\n\n# bind rows\n\nrowbind(x, y, fill = TRUE) # always fills\n\n# bind rows using a list\n\nrowbind(list(x, y), idcol = \"id\")\n\n# bind columns\n\nbase::cbind(x, y)\n\nadd_vars(x) <- y # modifies x but keeps data structure and attributes\n```\n:::\n\n\n## data.table\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- data.table(1:3)\ny <- data.table(4:6)\nz <- data.table(7:9, 0L)\n\n# bind rows\n\nrbind(x, y, fill = TRUE)\n\n# bind rows using a list\n\nrbindlist(list(x, y), idcol = \"id\")\n\n# bind columns\n\nbase::cbind(x, y)\n\nx <- base::cbind(x, y) # modifies x but column names are not changed\n```\n:::\n\n\n## dplyr\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- data.table(1:3)\ny <- data.table(4:6)\nz <- data.table(7:9, 0L)\n\n# bind rows\n\nbind_rows(x, y) # always fills\n\n# bind rows using a list\n\nbind_rows(list(x, y), .id = \"id\")\n\n# bind columns\n\nbind_cols(x, y)\n\nx <- bind_cols(x, y) # modifies x and replace names\n```\n:::\n\n:::\n\n## Efficient functions (maybe)\n\n## Other useful functions in collapse\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# quick summary (From STATA summarize and xtsummarize)\n\nqsu(df, cols = c(\"realf\"))\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}