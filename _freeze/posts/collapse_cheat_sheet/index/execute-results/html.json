{
  "hash": "fd8f60a4d188b8216e6410d3501b2d64",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Collapse Cheat sheet\"\ndescription: \"Syntax translation from dplyr and data.tablen to collapse\"\nauthor: \"PIP Technical team\"\ndate: \"03/13/2025\"\ncategories: [collapse, data.table, dplyr, efficiency]\nformat:\n  html:\n    toc: true\neditor_options: \n  chunk_output_type: console\nexecute:\n  output: false\n---\n\n\n\n## Introduction\n\nThis post is inspired in the Atreba's blog: [A data.table and dplyr tour](https://atrebas.github.io/post/2019-03-03-datatable-dplyr/). The objective of this post is to complement Atreba's one with the syntax of the [`{collapse}`](https://sebkrantz.github.io/collapse/) R package.\n\n## Basic understanding of the three packages\n\n### dplyr\n\nA grammar of data manipulation in R which provides a consistent set of verbs to help you solve the most common data manipulation challenges. It is part of the `tidyverse` universe. [Click here for more information.](https://dplyr.tidyverse.org/).\n\n### data.table\n\nA syntax to operate data manipulation operations, such as subset, group, update, join, etc. It reduces programming and compute time tremendously. [Click here for more information.](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html)\n\n### collapse\n\nA large C/C++ based package for data transformation and statistical computing in R. It aims to facilitate complex data transformations, explorations and computing tasks in R, while making code fast, flexible, parsimonious and programmer friendly. [Click here for more information.](https://sebkrantz.github.io/collapse/) \n\n## Load libraries\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(data.table)\nlibrary(collapse)\n```\n:::\n\n\n\n## Data \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)\n\n# Number of rows\nn <- 10000\n\n# Generate fake data\ndf <- data.frame(\n  id1 = 1:n,  # Unique ID\n  id2 = sample(1:500, n, replace = TRUE),  # Repeating ID\n  dt = seq.Date(from = as.Date(\"2023-01-01\"), by = \"day\", length.out = n),  # Dates\n  tm = format(seq.POSIXt(from = as.POSIXct(\"2023-01-01 00:00:00\"), \n                         by = \"hour\", length.out = n), \"%H:%M:%S\"),  # Time\n  ch = sample(c(\"A\", \"B\", \"C\", \"D\"), n, replace = TRUE),  # Character\n  int = sample(1:100, n, replace = TRUE),  # Integer\n  log = sample(c(TRUE, FALSE), n, replace = TRUE),  # Logical\n  realf = runif(n, 1, 100),  # Real (float),\n  reald = runif(n),  # Real ,\n  fct = factor(sample(c(\"X\", \"Y\", \"Z\"), n, replace = TRUE))  # Factor\n)\n\n# Ensure uniqueness\ndf <- unique(df, by = c(\"id1\", \"id2\"))\ndt <- setDT(df)\ntb <- as_tibble(df)\n```\n:::\n\n\n\n## Basic use\n\n### Filtering rows\n\n#### Filter rows using indices\n\n::: panel-tabset\n## collapse\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# super efficient\ndf |> \n  ss(2:5)\n\n# efficient\ndf |> \n  fsubset(2:5)\n```\n:::\n\n\n\n## data.table\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[2:5]\n```\n:::\n\n\n\n## dplyr\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntb |> \n  slice(2:5)\n\n# or using index like any data.frame\ntb[2:5,]\n\n# you need to add the comma. Otherwise, you get a different result\ntb[2:5]\n```\n:::\n\n\n:::\n\n#### Discard rows using negative indices\n\n::: panel-tabset\n## collapse\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  ss(-c(2:5)) |> \n  head(4)\n\ndf |> \n  ss(-c(2:5)) |> \n  head(4)\n```\n:::\n\n\n\n## data.table\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[!2:5] |> \n  head(4)\n```\n:::\n\n\n\n## dplyr\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntb |> \n  slice(-(2:5)) |> \n  head(4)\n```\n:::\n\n\n:::\n\n#### Filter rows using conditions\n\n::: panel-tabset\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# using named objects to filer data\nch  <- \"A\" # data has this as variable name\nfct <- \"A\" # data has this as variable name\nx  <- \"A\"\n```\n:::\n\n\n\n## collapse\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  fsubset(ch == \"A\" & id1 == 6)\n\ndf |> \n  fsubset(ch == x & id1 == 6)\n\n# This works\ndf |> \n  fsubset(ch == ch & id1 == 6)\n\n# This does not work\ndf |> \n  fsubset(ch == fct & id1 == 6)\n\n# This through error\ndf |> \n  fsubset(ch == get(fct) & id1 == 6) |> \n  try()\n\n# This works\ndf |> \n  fsubset(ch == get(\"fct\", envir = -2) & id1 == 6) \n\n# NOTE: is there a better way?\n```\n:::\n\n\n\n## data.table\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[ch == \"A\" & id1 == 6]\n\ndt[ch == x & id1 == 6]\n\ndt[ch ==ch & id1 == 6]\n\n# this does not work\ndt[ch == fct & id1 == 6]\n\n\ndt[ch == eval(fct) & id1 == 6]\n\n# These work but they are  verbose\ndt[ch == get(\"fct\", envir = parent.frame()) & id1 == 6]\ndt[ch == get(\"fct\", envir = -2) & id1 == 6]\n```\n:::\n\n\n\n## dplyr\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntb |> \n  filter(ch == \"A\" & id1 == 6)\n\ntb |> \n  filter(ch == x & id1 == 6)\n\ntb |> \n  filter(ch == ch & id1 == 6)\n\n# does not work\ntb |> \n  filter(ch == fct & id1 == 6)\n\n# works really well\ntb |> \n  filter(ch == !!fct & id1 == 6)\n```\n:::\n\n\n:::\n\n### Summarise data\n\n#### Summarise columns\n\n::: panel-tabset\n## collapse\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# efficient\ndf |>\n  fsummarise(sum_rf = fsum(realf),\n             sd_rd = fsd(reald))\n\n# shorthand\ndf |>\n  smr(sum_rf = fsum(realf),\n      sd_rd = fsd(reald))\n```\n:::\n\n\n\n## data.table\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[, sum(realf)] # returns a vector\n\ndt[, .(sum(realf))] # returns a data.table\n\ndt[, .(sum_rf = sum(realf), # returns a data.table with named columns\n       sd_rd = sd(reald))]\n```\n:::\n\n\n\n## dplyr\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(tb, sum(realf)) # returns a tibble\n\ntb |> \n  summarise(sum_rf = sum(realf), # returns a tibble\n            sd_rd = sd(reald))\n```\n:::\n\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}