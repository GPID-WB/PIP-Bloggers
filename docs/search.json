[
  {
    "objectID": "posts/SysCall/index.html",
    "href": "posts/SysCall/index.html",
    "title": "Understanding R’s Call Stack: sys.call() and Friends",
    "section": "",
    "text": "If you’ve ever wanted an R function to know who called it, inspect its own body, or adapt based on where it’s running, then you’re looking for call stack introspection — and functions like sys.call(), sys.parent(), and sys.function() are your best tools.\nIn this post, we’ll demystify these powerful functions, showing how they allow you to:\n\nTrack who called a function (sys.parent())\nSee how it was called (sys.call())\nAccess the actual function object being executed (sys.function())\n\nWe’ll also take a brief look at formals(), body() and environment() — three essential tools for inspecting a function’s signature and its defining environment.\nUnderstanding these functions isn’t just for advanced metaprogramming — they’re incredibly useful for logging, debugging, writing wrappers, building APIs, or just making your code more transparent and robust.\nLet’s get started with a minimal example of how the call stack works in R."
  },
  {
    "objectID": "posts/SysCall/index.html#introduction",
    "href": "posts/SysCall/index.html#introduction",
    "title": "Understanding R’s Call Stack: sys.call() and Friends",
    "section": "",
    "text": "If you’ve ever wanted an R function to know who called it, inspect its own body, or adapt based on where it’s running, then you’re looking for call stack introspection — and functions like sys.call(), sys.parent(), and sys.function() are your best tools.\nIn this post, we’ll demystify these powerful functions, showing how they allow you to:\n\nTrack who called a function (sys.parent())\nSee how it was called (sys.call())\nAccess the actual function object being executed (sys.function())\n\nWe’ll also take a brief look at formals(), body() and environment() — three essential tools for inspecting a function’s signature and its defining environment.\nUnderstanding these functions isn’t just for advanced metaprogramming — they’re incredibly useful for logging, debugging, writing wrappers, building APIs, or just making your code more transparent and robust.\nLet’s get started with a minimal example of how the call stack works in R."
  },
  {
    "objectID": "posts/SysCall/index.html#a-minimal-example-of-a-call-stack",
    "href": "posts/SysCall/index.html#a-minimal-example-of-a-call-stack",
    "title": "Understanding R’s Call Stack: sys.call() and Friends",
    "section": "A Minimal Example of a Call Stack",
    "text": "A Minimal Example of a Call Stack\nLet’s define three simple functions:\n\nbaz &lt;- function() {\n  print(\"Inside baz()\")\n  print(sys.call())\n  print(sys.parent()) \n}\n\nbar &lt;- function() {\n  print(\"Inside bar()\")\n  baz()\n}\n\nfoo &lt;- function() {\n  print(\"Inside foo()\")\n  bar()\n}\n\nfoo()\n\n[1] \"Inside foo()\"\n[1] \"Inside bar()\"\n[1] \"Inside baz()\"\nbaz()\n[1] 25\n\n\nLet’s focus on the last number. What does it mean?\n\nsys.parent() is just a number\nThe function sys.parent() doesn’t return a function or a call — it returns a number. That number is an index into R’s call stack — the internal list of active function calls.\nIn our example, this is the call stack when baz() is executing:\n2: bar()\n1: foo()\n0: global environment\nSo when baz() calls sys.parent(), it gets the index of its direct caller (bar()), which happens to be at position 2 in the stack. If you want to see what that parent call was, you’d need to call sys.call(sys.parent()). But that is not what you see here.\n\n\nWhy is sys.parent() = 2 in the console, but 31 (or another number) in a Quarto document?\nWhen you run this code interactively in R, the call stack is shallow: you’re at the top-level environment (frame 0), and your functions are being called directly.\nBut when you render a Quarto document, things change. Your code is being executed within internal functions used by Quarto and knitr. So your simple foo() call is actually wrapped in 30+ layers of function calls. That’s why sys.parent() might return something like 31.\nSo even though it feels like you’re calling foo(), you’re actually calling something like:\nquarto::render -&gt; knitr::knit -&gt; evaluate::evaluate -&gt; ... -&gt; foo()\n\n\n\n\n\n\nThe takeaway?\n\n\n\nThe value returned by sys.parent() is always relative to the current call stack. Don’t assume it’s fixed — it depends on the context where your code runs.\n\n\nThis is especially important when writing packages or code that might run inside knitr, shiny, testthat, or other frameworks."
  },
  {
    "objectID": "posts/SysCall/index.html#sys.call-what-was-the-actual-call",
    "href": "posts/SysCall/index.html#sys.call-what-was-the-actual-call",
    "title": "Understanding R’s Call Stack: sys.call() and Friends",
    "section": "sys.call() – What Was the Actual Call?",
    "text": "sys.call() – What Was the Actual Call?\nsys.call() returns the actual call expression that invoked the current frame.\nTo trace the current call and the parent call:\n\nbaz &lt;- function() {\n  cat(\"I'm in:\", as.character(sys.call()), \"\\n\")\n  cat(\"I was called by:\", as.character(sys.call(sys.parent())), \"\\n\")\n}\nbar &lt;- \\() {\n  cat(\"I'm bar() and I will call baz()\\n\")\n  baz()\n}\n\n# When baz() is called directly, it is its own parent\nbaz()\n\nI'm in: baz \nI was called by: baz \n\n# when bar() is called, bar() is the parent of baz()\nbar()\n\nI'm bar() and I will call baz()\nI'm in: baz \nI was called by: bar"
  },
  {
    "objectID": "posts/SysCall/index.html#sys.parent-whos-your-caller",
    "href": "posts/SysCall/index.html#sys.parent-whos-your-caller",
    "title": "Understanding R’s Call Stack: sys.call() and Friends",
    "section": "sys.parent() – Who’s Your Caller?",
    "text": "sys.parent() – Who’s Your Caller?\nIf you want to know who called the current function, use sys.parent():\n\ngoo &lt;- function() {\n  parent &lt;- sys.parent()\n  cat(\"Parent frame index:\", parent, \"\\n\")\n  cat(\"Parent call:\", as.character(sys.call(parent)), \"\\n\")\n}\n\nfoo &lt;- function(x) {\n  goo()\n}\n\nfoo()\n\nParent frame index: 24 \nParent call: foo"
  },
  {
    "objectID": "posts/SysCall/index.html#use-case-identifying-the-calling-function-for-errors-and-logs",
    "href": "posts/SysCall/index.html#use-case-identifying-the-calling-function-for-errors-and-logs",
    "title": "Understanding R’s Call Stack: sys.call() and Friends",
    "section": "Use case: Identifying the Calling Function (for Errors and Logs)",
    "text": "Use case: Identifying the Calling Function (for Errors and Logs)\nKnowing the name of the function that called you can be genuinely useful — especially for writing descriptive error messages, debugging tools, or custom logging systems.\nImagine you’re building a helper function that will be used in multiple places across your codebase, and you want to alert the user exactly where something went wrong.\nHere’s a simplified example:\n\nvalidate_input &lt;- function(x) {\n  if (missing(x)) {\n    caller &lt;- as.character(sys.call(sys.parent()))[1]\n    stop(sprintf(\"Function '%s' was called without a required argument 'x'\", caller))\n  }\n}\n\nNow we can call this helper from other functions:\n\nfoo &lt;- function(x) {\n  validate_input(x)\n  # Do something with x\n}\n\n# Try running it without x\nfoo()\n\nError in validate_input(x): Function 'foo' was called without a required argument 'x'\n\n\nThis becomes very powerful when writing frameworks, internal utilities, or packages where you want reusable components to report context-aware messages.\nYou can even take it further and include the full call expression of the parent:\n\nvalidate_input &lt;- function(x) {\n  if (missing(x)) {\n    call_expr &lt;- deparse(sys.call(sys.parent()))\n    stop(sprintf(\"Invalid call: %s — missing argument 'x'\", call_expr))\n  }\n}\n\nbar &lt;- function(x, y = 4, z = \"hola\") {\n  validate_input(x)\n}\n\nbar(y = 3, z = 8)\n\nError in validate_input(x): Invalid call: bar(y = 3, z = 8) — missing argument 'x'\n\n# if you don't call arguments, they won't be shown\n# even if they have defaults... \n# `sys.call(sys.parent())` shows exactly how it was called.\nbar()\n\nError in validate_input(x): Invalid call: bar() — missing argument 'x'\n\n\nThis pattern is especially helpful when writing functions that will be used by other developers or in larger pipelines, where it’s not always obvious where something failed.\n\n\n\n\n\n\nTip\n\n\n\nUse sys.call(sys.parent()) when you want to report errors as if they came from the caller, not the helper.\n\n\nNow that we’ve explored who called a function and how, let’s go one step deeper — and ask: what is this function we’re inside of?"
  },
  {
    "objectID": "posts/SysCall/index.html#sys.function-which-function-is-running",
    "href": "posts/SysCall/index.html#sys.function-which-function-is-running",
    "title": "Understanding R’s Call Stack: sys.call() and Friends",
    "section": "sys.function() – Which Function Is Running?",
    "text": "sys.function() – Which Function Is Running?\nWhile sys.call() tells you how a function was invoked, sys.function() tells you which function object is actually being executed in a specific frame.\nThis allows you to programmatically access and inspect a function’s:\n\nFormal arguments (its signature) via formals()\nBody (its actual code) via body()\nEnvironment (its context) via environment()\n\n\nExample: Inspecting the Current Function\n\ngoo &lt;- function(x = 42) {\n  fun &lt;- sys.function()            # The actual function object being run\n  cat(\"Function signature:\\n\")\n  print(formals(fun))             # What are the arguments?\n  cat(\"\\nFunction body:\\n\")\n  print(body(fun))                # What's the code inside?\n  cat(\"\\nFunction environment:\\n\")\n  print(environment(fun))         # Where was it defined?\n}\n\ngoo()\n\nFunction signature:\n$x\n[1] 42\n\n\nFunction body:\n{\n    fun &lt;- sys.function()\n    cat(\"Function signature:\\n\")\n    print(formals(fun))\n    cat(\"\\nFunction body:\\n\")\n    print(body(fun))\n    cat(\"\\nFunction environment:\\n\")\n    print(environment(fun))\n}\n\nFunction environment:\n&lt;environment: R_GlobalEnv&gt;\n\n\nThis triple combo gives you full programmatic access to the function’s internals.\n\n\nLooking Up the Caller Function\nYou can also use sys.function(sys.parent()) to inspect the function that called you.\n\ngoo &lt;- function() {\n  caller_fun &lt;- sys.parent() |&gt; \n    sys.function()\n  parent_fun &lt;- sys.parent() |&gt; \n    sys.call() |&gt; \n    as.character()  # this is important to be displayed by cat()\n  fun        &lt;- as.character(sys.call())\n  \n  cat(\"I'm\", fun, \"\\n\")\n  cat(\"I was called by\", parent_fun, \"\\n\")\n  cat(\"whose rocking body looks like this:\\n\") # I could not resist the bad joke... sorry\n  print(body(caller_fun))\n  cat(\"Caller function formals (or arguments):\\n\")\n  print(formals(caller_fun))\n  cat(\"Caller function environment:\\n\")\n  print(environment(caller_fun))\n}\n\nfoo &lt;- function(a = 1, b = 2) {\n  goo()\n}\n\nfoo()\n\nI'm goo \nI was called by foo \nwhose rocking body looks like this:\n{\n    goo()\n}\nCaller function formals (or arguments):\n$a\n[1] 1\n\n$b\n[1] 2\n\nCaller function environment:\n&lt;environment: R_GlobalEnv&gt;\n\n\nThis outputs the body, signature, and environment of foo() — the caller of goo().\n\n\nReal Use Case: Dynamic Function Logging\nSuppose you want to create a universal logger that tells you what function is running, how it was called, and from where:\n\nlog_context &lt;- function(y = \"hola\") {\n  this_fun &lt;- sys.function()\n  this_call &lt;- sys.call()\n  caller_call &lt;- sys.call(sys.parent())\n\n  cat(\"You are in function:\\n\")\n  print(this_call)\n  cat(\"Formal arguments:\\n\")\n  print(formals(this_fun))\n  cat(\"Called by:\\n\")\n  print(caller_call)\n}\n\nwrap_me &lt;- function(x = 10) {\n  # `x` is to used in other parts of `wrap_me()`\n  log_context()\n}\n\nwrap_me()\n\nYou are in function:\nlog_context()\nFormal arguments:\n$y\n[1] \"hola\"\n\nCalled by:\nwrap_me()\n\n\nThis allows meta-level logging, introspection, or debugging, especially when used inside package utilities, decorators, or dynamic wrappers.\n\n\nFinal Thoughts on sys.function()\n\n\n\nTool\nWhat it returns\n\n\n\n\nsys.function()\nFunction object for current frame\n\n\nformals(f)\nList of arguments for function f\n\n\nbody(f)\nThe code block (body) of function f\n\n\nenvironment(f)\nThe enclosing environment where f was defined"
  },
  {
    "objectID": "posts/SysCall/index.html#real-scenario-logging-with-caller-info",
    "href": "posts/SysCall/index.html#real-scenario-logging-with-caller-info",
    "title": "Understanding R’s Call Stack: sys.call() and Friends",
    "section": "Real Scenario: Logging with Caller Info",
    "text": "Real Scenario: Logging with Caller Info\nCustom log_debug() with automatic caller identification:\n\nlog_debug &lt;- function(message) {\n  caller &lt;- as.character(sys.call(sys.parent()))[1]\n  cat(sprintf(\"[DEBUG] [%s] %s\\n\", caller, message))\n}\n\nprocess_data &lt;- function(x) {\n  log_debug(\"Starting data processing\")\n  # ... do something ... with `x`\n  y &lt;- x * 2\n  print(y)\n  log_debug(\"Finished processing\")\n}\n\nprocess_data(42)\n\n[DEBUG] [process_data] Starting data processing\n[1] 84\n[DEBUG] [process_data] Finished processing"
  },
  {
    "objectID": "posts/SysCall/index.html#quick-reference",
    "href": "posts/SysCall/index.html#quick-reference",
    "title": "Understanding R’s Call Stack: sys.call() and Friends",
    "section": "Quick Reference",
    "text": "Quick Reference\n\n\n\nFunction\nDescription\n\n\n\n\nsys.call()\nReturns the call to the current function\n\n\nsys.call(n)\nReturns the call from frame n\n\n\nsys.parent()\nReturns the index of the parent frame\n\n\nsys.frame()\nReturns the environment of a given frame\n\n\nsys.function()\nReturns the function evaluated in a given frame\n\n\nparent.frame()\nShortcut for the parent environment"
  },
  {
    "objectID": "posts/collapse_cheat_sheet/index.html",
    "href": "posts/collapse_cheat_sheet/index.html",
    "title": "Collapse Cheat sheet",
    "section": "",
    "text": "This post is inspired in the Atreba’s blog: A data.table and dplyr tour. The objective of this post is to complement Atreba’s one with the syntax of the {collapse} R package."
  },
  {
    "objectID": "posts/collapse_cheat_sheet/index.html#introduction",
    "href": "posts/collapse_cheat_sheet/index.html#introduction",
    "title": "Collapse Cheat sheet",
    "section": "",
    "text": "This post is inspired in the Atreba’s blog: A data.table and dplyr tour. The objective of this post is to complement Atreba’s one with the syntax of the {collapse} R package."
  },
  {
    "objectID": "posts/collapse_cheat_sheet/index.html#basic-understanding-of-the-three-packages",
    "href": "posts/collapse_cheat_sheet/index.html#basic-understanding-of-the-three-packages",
    "title": "Collapse Cheat sheet",
    "section": "Basic understanding of the three packages",
    "text": "Basic understanding of the three packages\n\ndplyr\nA grammar of data manipulation in R which provides a consistent set of verbs to help you solve the most common data manipulation challenges. It is part of the tidyverse universe. Click here for more information..\n\n\ndata.table\nA syntax to operate data manipulation operations, such as subset, group, update, join, etc. It reduces programming and compute time tremendously. Click here for more information.\n\n\ncollapse\nA large C/C++ based package for data transformation and statistical computing in R. It aims to facilitate complex data transformations, explorations and computing tasks in R, while making code fast, flexible, parsimonious and programmer friendly. Click here for more information."
  },
  {
    "objectID": "posts/collapse_cheat_sheet/index.html#load-libraries",
    "href": "posts/collapse_cheat_sheet/index.html#load-libraries",
    "title": "Collapse Cheat sheet",
    "section": "Load libraries",
    "text": "Load libraries\n\nlibrary(dplyr)\nlibrary(data.table)\nlibrary(collapse)\nlibrary(tidyverse)"
  },
  {
    "objectID": "posts/collapse_cheat_sheet/index.html#data",
    "href": "posts/collapse_cheat_sheet/index.html#data",
    "title": "Collapse Cheat sheet",
    "section": "Data",
    "text": "Data\n\nset.seed(42)\n\n# Number of rows\nn &lt;- 10000\n\n# # Generate fake data\n# df &lt;- data.frame(\n#   id1 = 1:n,  # Unique ID\n#   id2 = sample(1:500, n, replace = TRUE),  # Repeating ID\n#   dt = seq.Date(from = as.Date(\"2023-01-01\"), by = \"day\", length.out = n),  # Dates\n#   tm = format(seq.POSIXt(from = as.POSIXct(\"2023-01-01 00:00:00\"), \n#                          by = \"hour\", length.out = n), \"%H:%M:%S\"),  # Time\n#   ch = sample(c(\"A\", \"B\", \"C\", \"D\"), n, replace = TRUE),  # Character\n#   int = sample(1:100, n, replace = TRUE),  # Integer\n#   log = sample(c(TRUE, FALSE), n, replace = TRUE),  # Logical\n#   realf = runif(n, 1, 100),  # Real (float),\n#   reald = runif(n),  # Real ,\n#   fct = factor(sample(c(\"X\", \"Y\", \"Z\"), n, replace = TRUE))  # Factor\n# )\n\nset.seed(42)\n\n# Number of rows\nn &lt;- 10000\n\n# Generate fake data with some NAs\ndf &lt;- data.frame(\n  id1 = 1:n,  # Unique ID\n  id2 = sample(1:500, n, replace = TRUE),  # Repeating ID\n  dt = sample(c(seq.Date(from = as.Date(\"2023-01-01\"), by = \"day\", length.out = n), NA), n, replace = TRUE),  # Dates with NAs\n  tm = sample(c(format(seq.POSIXt(from = as.POSIXct(\"2023-01-01 00:00:00\"), \n                                  by = \"hour\", length.out = n), \"%H:%M:%S\"), NA), n, replace = TRUE),  # Time with NAs\n  ch = sample(c(\"A\", \"B\", \"C\", \"D\", NA), n, replace = TRUE, prob = c(0.24, 0.24, 0.24, 0.24, 0.04)),  # Character with some NAs\n  int = sample(c(1:100, NA), n, replace = TRUE),  # Integer with some NAs\n  log = sample(c(TRUE, FALSE, NA), n, replace = TRUE, prob = c(0.49, 0.49, 0.02)),  # Logical with some NAs\n  realf = sample(c(runif(n, 1, 100), NA), n, replace = TRUE),  # Real (float) with some NAs\n  reald = sample(c(runif(n), NA), n, replace = TRUE),  # Real with some NAs\n  fct = factor(sample(c(\"X\", \"Y\", \"Z\", NA), n, replace = TRUE, prob = c(0.32, 0.32, 0.32, 0.04)))  # Factor with some NAs\n)\n\n# Print summary to check distribution of NAs\nsummary(df)\n\n\n# Ensure uniqueness\ndf &lt;- unique(df, by = c(\"id1\", \"id2\"))\ndt &lt;- copy(setDT(df))\ntb &lt;- as_tibble(df)"
  },
  {
    "objectID": "posts/collapse_cheat_sheet/index.html#basic-use",
    "href": "posts/collapse_cheat_sheet/index.html#basic-use",
    "title": "Collapse Cheat sheet",
    "section": "Basic use",
    "text": "Basic use\n\nFiltering rows\n\nFilter rows using indices\n\ncollapsedata.tabledplyr\n\n\n\n# super efficient\ndf |&gt; \n  ss(2:5)\n\n# efficient\ndf |&gt; \n  fsubset(2:5)\n\n\n\n\ndt[2:5]\n\n\n\n\ntb |&gt; \n  slice(2:5)\n\n# or using index like any data.frame\ntb[2:5,]\n\n# you need to add the comma. Otherwise, you get a different result\ntb[2:5]\n\n\n\n\n\n\nDiscard rows using negative indices\n\ncollapsedata.tabledplyr\n\n\n\ndf |&gt; \n  ss(-c(2:5)) |&gt; \n  head(4)\n\ndf |&gt; \n  ss(-c(2:5)) |&gt; \n  head(4)\n\n\n\n\ndt[!2:5] |&gt; \n  head(4)\n\n\n\n\ntb |&gt; \n  slice(-(2:5)) |&gt; \n  head(4)\n\n\n\n\n\n\nFilter rows using conditions\n\ncollapsedata.tabledplyr\n\n\n\ndf |&gt; \n  fsubset(ch == \"A\" & id1 == 6)\n\ndf |&gt; \n  fsubset(ch == x & id1 == 6)\n\n# This works\ndf |&gt; \n  fsubset(ch == ch & id1 == 6)\n\n# This does not work\ndf |&gt; \n  fsubset(ch == fct & id1 == 6)\n\n# This through error\ndf |&gt; \n  fsubset(ch == get(fct) & id1 == 6) |&gt; \n  try()\n\n# This works\ndf |&gt; \n  fsubset(ch == get(\"fct\", envir = -2) & id1 == 6) \n\n# NOTE: is there a better way?\n\n\n\n\ndt[ch == \"A\" & id1 == 6]\n\ndt[ch == x & id1 == 6]\n\ndt[ch ==ch & id1 == 6]\n\n# this does not work\ndt[ch == fct & id1 == 6]\n\n\ndt[ch == eval(fct) & id1 == 6]\n\n# These work but they are  verbose\ndt[ch == get(\"fct\", envir = parent.frame()) & id1 == 6]\ndt[ch == get(\"fct\", envir = -2) & id1 == 6]\n\n\n\n\ntb |&gt; \n  filter(ch == \"A\" & id1 == 6)\n\ntb |&gt; \n  filter(ch == x & id1 == 6)\n\ntb |&gt; \n  filter(ch == ch & id1 == 6)\n\n# does not work\ntb |&gt; \n  filter(ch == fct & id1 == 6)\n\n# works really well\ntb |&gt; \n  filter(ch == !!fct & id1 == 6)\n\n\n\n\n\n\nFilter unique rows\n\ncollapsedata.tabledplyr\n\n\n\n# Remove duplicate rows\ndf |&gt;\n  funique()\n\n# Keeps only one row per unique value in id2\ndf |&gt;\n  funique(cols = \"int\") # selecting column by col name \ndf |&gt;\n  funique(cols = 6)     # selecting column by indices\ndf |&gt;\n  funique(cols = names(df) %in% \"int\") # with logical condition\n\n\n\n\n # Remove duplicate rows\ndt |&gt;\n  unique()\n\n# Keeps only one row per unique value in id2\ndt |&gt;\n  unique(by = \"id2\")  \n\n\n\n\n# Remove duplicate rows\ntb |&gt;\n  distinct()\n\n# Keeps only one row per unique id1\ntb |&gt; distinct(id1, .keep_all = TRUE) # keep all col\n\n\n\n\n\n\nDiscard rows with missing values\n\ncollapsedata.tabletidyverse\n\n\n\n# Discard rows with any NA value\ndf |&gt;\n  na_omit()\n\n# Discard rows with NA value for selected col\ndf |&gt;\n  na_omit(cols = \"ch\")\n\n# More flexible options:\n# Remove rows where more than 50% of values are missing\ndf |&gt;\n  na_omit(prop = 0.5)\n\n\n\n\n# Discard rows with any NA value\ndt |&gt;\n  na_omit()\n\n# Discard rows with NA value for selected col\ndt &lt;- dt[!is.na(ch)]\n\n\n\n\n# Discard rows with any NA value\ntb |&gt;\n  tidyr::drop_na()\n\n# Discard rows with NA value for selected col\ntb |&gt; \n  tidyr::drop_na(ch)\n\n\n\n\n\n\nOther filters: slice options\n\ncollapsedata.tabledplyr\n\n\n\ndf |&gt;\n  fslice(n = 3)                 # First 3 rows\ndf |&gt;\n  fslice(n   = 3, \n         how = \"last\")          # Last 3 rows\ndf |&gt;\n  fslice(n = 0.1)               # Fraction of rows: first 10% of rows\n\nfslice(n        = 3, \n       how      = \"min\", \n       order.by = int)          # 3 obs with lowest int\n\n# TODO: add fslicev()\n\n\n\n\n# Frist 3 rows\ndt[1:3, ]   # First 3 rows, all columns\n\n\n# Last 3 rows\ndt[(.N-2):.N]  # .N gives the total number of rows\n\n# Fraction of rows: first 10% of rows\ndt[1:(.N * 0.1)]\n\n\n# 3 obs with lowest int\ndt[order(int)][1:3]\n\n\n\n\n# First 3 rows\ntb |&gt;\n  slice_head(n = 3)\n\n# Last 3 rows\ntb |&gt;\n  slice_tail(n = 3)\n\n# Fraction of rows: first 10% of rows\ntb |&gt;\n  slice_head(prop = 0.1)\n\n# 3 obs with lowest int\ntb |&gt;\n  slice_min(order_by = int, \n            n        = 3) # all rows\n\ntb |&gt;\n slice_min(order_by = int, \n           n        = 3, \n           with_ties = FALSE) \n\n\n\n\n\n\n\nSort rows\n\nSort rows by column(s)\n\ncollapsedata.tabledplyr\n\n\n\ndf |&gt;\n  roworder(id1)  \n\ndf |&gt;\n  roworder(-id2)      # Sort by decreasing order of id2\n\ndf |&gt;\n  roworder(id1, -id2) # Sort by multiple cols \n\n\n\n\ndt[order(id2)]    # This makes a copy\n\nsetorder(dt, id2) # To modify by reference  \n\ndt[order(-id2)]   # Sort by decreasing order\n\ndt[order(id1, -id2)] # Sort by multiple cols \n\n\n\n\ntb |&gt;\n  arrange(id2)\n\ntb |&gt;\n  arrange(desc(id2)) # Sort by decreasing order\n\n# Sort by multiple cols \ndf |&gt;\n   arrange(id1, desc(id2))\n\n\n\n\n\n\n\nSelect columns\n\nSelect one or more columns\n\ncollapsedata.tabledplyr\n\n\n\n## Select one column   ####\n# _________________________ \n\n# by index\ndf |&gt;\n  fselect(2)\n\ndf |&gt;\n  slt(2) # shorthand for fselect\n\n# by name\n\ndf |&gt;\n  fselect(id2)  # returns a dataframe \n\n## Select multiple columns ####\n# _____________________________ \n\ndf |&gt;\n  fselect(id1, id2, fct)\n\ndf |&gt;\n  fselect(id1, ch:fct)\n\n\n\n\n## Select one column   ####\n# _________________________ \n\n# by index\ndt[[3]]  # returns a vector\ndt[, 3]  # returns a data.table\n\n# by name\ndt[, list(id2)] # returns a data.table\ndt[, .(id2)]    # returns a data.table (. is an alias for list)\ndt[, \"id2\"]     # returns a data.table\ndt[, id2]       # returns a vector\ndt[[\"id2\"]]     # returns a vector\n\n## Select multiple columns ####\n# _____________________________ \n\ndt[, .(id1, id2, int)]\ndt[, list(id1, id2, int)]\ndt[, id2:int] # select columns between id2 and int\n\n\n\n\n## Select one column   ####\n# _________________________ \n\ntb |&gt;\n  select(id2)               # returns a tibble\n\npull(tb, id2, name = ch)    # returns a (named) vector\ntb[, \"id2\"]                 # returns a tibble\ntb[[\"id2\"]]                 # returns a vector\n\n## Select multiple columns ####\n# _____________________________ \n\ndf |&gt;\n  select(id1, id2, ch)\ndf |&gt;\n  select(id1, ch:fct)\n\n\n\n\n\n\nExclude columns\n\ncollapsedata.tabledplyr\n\n\n\n# Exclude columns by column names \ndf |&gt;\n  fselect(-dt, -tm)\n\n# Using a character vector \ncols &lt;- c(\"dt\", \"tm\")\n\ndf |&gt;\n  fselect(-cols)  # does not work \n\nError in -cols: invalid argument to unary operator\n\ndf |&gt;\n  fselect(!cols) # does not work \n\nError in !cols: invalid argument type\n\n# what is a better way to do this?\n\n\n\n\n# Exclude columns by column names \ndt[, !c(\"dt\", \"tm\")]\n\n# Using a character vector \ncols &lt;- c(\"dt\", \"tm\")\n\ndt[, ..cols] \n# .. prefix means 'one-level up', as cols is outside the parent environment \n\ndt[, !..cols] # or dt[, -..cols]\n\n\n\n\n# Exclude columns by column names \ntb |&gt;\n  select( -dt, -tm)\n\n# Using a character vector \ncols &lt;- c(\"dt\", \"tm\")\n\ntb |&gt;\n  select(all_of(cols))\n\ntb |&gt;\n  select(-all_of(cols))\n\n\n\n\n\n\nOther selections - not sure it is relevant, to check\n\n\n\nMiscellaneous\n\nRead & write data\n\nWrite\n\ncollapsedata.tabledplyr\n\n\n\n# no specific functions for reading and writing data \n\n\n\n\nfwrite(dt, \n       \"DT.csv\")                # write to csv\n\n\nfwrite(dt, \n       \"DT.txt\", \n       sep = \"\\t\")              # write to a tab-delimited file\n\n\n\n\nreadr::write_csv(tb, \n                 \"tb.csv\")  # write to csv\n\nreadr::write_delim(tb, \n                   \"tb.txt\", \n                   delim = \"\\t\")  # write to a tab-delimited file\n\n\n\n\n\n\nRead\n\ncollapsedata.tabledplyr\n\n\n\n# no specific functions for reading and writing data \n\n\n\n\nfread(\"dt.csv\")   # read csv\n# fread(\"DT.csv\", verbose = TRUE) # full details\n\nfread(\"dt.txt\", sep = \"\\t\") # read tab-delimited file\n\n# Read and rbind several files\nrbindlist(\n  lapply(c(\"dt.csv\", \"dt.csv\"), \n         fread))\n\n\n\n\nreadr::read_csv(\"tb.csv\")  # read csv\n\nreadr::read_delim(\"tb.txt\", \n                  delim = \"\\t\")  # read tab-delimited file\n\n# Read and rbind several files\nc(\"tb.csv\",  \"tb.csv\") |&gt;\n  purrr::map_dfr(readr::read_csv)\n\n\n\n\n\n\n\nReshape data\n\ncollapsedata.tabledplyr\n\n\n\n# ---- Long to Wide ----\nwide_pivot &lt;- pivot(df, \n                    ids    = c(\"id1\", \"id2\", \"dt\"),  # Columns to keep\n                    values = \"int\",              # Column with values\n                    names  = \"ch\",   # Column whose values become new cols\n                    how    = \"wider\")               # Reshape to wide format\n\n# ---- Wide to Long ----\nlong_pivot &lt;- pivot(wide_pivot, \n                    ids    = c(\"id1\", \"id2\", \"dt\"),  \n                    values = NULL,  \n                    names  = list(\"ch\", \"int\"),  \n                    how    = \"longer\")     \n\n\n\n\n# ---- Long to Wide ----\nwide_dt &lt;- dcast(dt, \n                 id1 + id2 + dt ~ ch, \n                 value.var = \"int\")\n\n# ---- Wide to Long ----\nlong_dt &lt;- melt(wide_dt, \n                id.vars       = c(\"id1\", \"id2\", \"dt\"), \n                variable.name = \"ch\", \n                value.name    = \"int\")\n\n\n\n\n# ---- Long to Wide ----\ntb_wide &lt;- tb |&gt;\n  # rm NAs\n  filter(!is.na(ch)) |&gt;\n  pivot_wider(names_from  = ch, \n              values_from = int)\n\n# ---- Wide to Long ----\ntb_long &lt;- tb_wide |&gt;\n  pivot_longer(cols      = c(\"A\", \"D\", \"C\", \"B\"),\n               values_to = \"int\",\n               names_to  = \"ch\")\n\n\n\n\n\n\n\nSummarise data\n\nSummarise columns\n\ncollapsedata.tabledplyr\n\n\n\n# efficient\ndf |&gt;\n  fsummarise(sum_rf = fsum(realf),\n             sd_rd = fsd(reald))\n\n# shorthand\ndf |&gt;\n  smr(sum_rf = fsum(realf),\n      sd_rd = fsd(reald))\n\n\n\n\ndt[, sum(realf)] # returns a vector\n\ndt[, .(sum(realf))] # returns a data.table\n\ndt[, .(sum_rf = sum(realf), # returns a data.table with named columns\n       sd_rd = sd(reald))]\n\n\n\n\nsummarise(tb, sum(realf)) # returns a tibble\n\ntb |&gt; \n  summarise(sum_rf = sum(realf), # returns a tibble\n            sd_rd = sd(reald))\n\n\n\n\n\n\nHelper functions\n\ncollapsedata.tabledplyr\n\n\nThe package includes fsum,fprod, fmedian, fmode, fvar, fsd, fmin,fmax,fnth, ffirst, flast,fnobs, and fndistinct.\n\n\nThe package includes first, last and uniqueN.\n\n\nThe package includes first, last, n, nth, and n_distinct.\n\n\n\n\n\n\nManipulations of columns\n\ncollapsedata.tabledplyr\n\n\n\n # Add one oe several columns (can also use ftransform)\ndf &lt;- df |&gt;\n  fmutate(log_rf = log(realf)) \n\ndf &lt;- df |&gt;\n  fmutate(log_rd = log(reald),\n           sqrt_rd = sqrt(reald))\n\n# Create one column and eliminate others\nfcompute(df, log2_rf = log_rf*2) \n\n # remove columns\ndf &lt;- df |&gt;\n  fselect(-log_rf,-log_rd,-sqrt_rd)\n\n\n\n\n# Add one column\ndt[, log_rf := log(realf)] \n\n# Add several columns\ndt[, ':=' (log_rd = log(reald), \n           sqrt_rd = sqrt(reald))]\n\n# Create one column and eliminate others\ndt[, .(log2_rf = log_rf*2)] \n\n# remove columns\ndt[, c(\"log_rf\", \"log_rd\", \"sqrt_rd\") := NULL] \n\n\n\n\n# Add one or several column\ntb &lt;- tb |&gt; \n  mutate(log_rf = log(realf))\n\ntb &lt;- tb |&gt; \n  mutate(log_rd = log(reald), \n           sqrt_rd = sqrt(reald))\n\n# Create one column and eliminate others\ntransmute(tb, log2_rf = log_rf*2)\n\n# remove columns\ntb &lt;- tb |&gt; \n  select(-log_rf,-log_rd,-sqrt_rd)\n\n\n\n\n\n\nby\n\ncollapsedata.tabledplyr\n\n\n\ndf |&gt; \n  fgroup_by(ch)|&gt;\n  fsummarise(sumrf = fsum(realf)) # ordered and indexed results\n\n# Assigned column name\n\ndf |&gt; \n  fgroup_by(abc = tolower(ch))|&gt;\n  fsummarise(sumrf = fsum(realf))\n\n# Add a column with number of observations for each group\n\ndf |&gt;\n  fgroup_by(ch)|&gt;\n  fcount(add = TRUE)\n\n\n\n\ndt[, .(sumrf = sum(realf)), by = \"ch\"] # unordered results\n\n# Reordered and indented:\n\ndt[, keyby = ch,\n     .(sumrf = sum(realf))]\n\n# Assigning column name\n\ndt[, keyby = .(abc = tolower(ch)),\n     .(sumrf = sum(realf))]\n\n# Add a column with number of observations for each group\n\ndt[, n := .N, by = ch][]\ndt[, n := NULL] # remove for consistency\n\n\n\n\ntb |&gt; \n  group_by(ch)|&gt;\n  summarise(sumrf = sum(realf)) # ordered results\n\n# Assigned column name\n\ntb |&gt; \n  group_by(abc = tolower(ch))|&gt;\n  summarise(sumrf = sum(realf))\n\n# Add a column with number of observations for each group\n\ntb |&gt;\n  group_by(ch)|&gt;\n  add_tally()\n\n# or...\n\nadd_count(tb, ch)"
  },
  {
    "objectID": "posts/collapse_cheat_sheet/index.html#going-further",
    "href": "posts/collapse_cheat_sheet/index.html#going-further",
    "title": "Collapse Cheat sheet",
    "section": "Going further",
    "text": "Going further\n\nAdvanced columns manipulation\n\ncollapsedata.tabledplyr\n\n\n\n# Summarize columns\ndf |&gt;\n  fsummarise(across(c(\"realf\", \"reald\"),\n            fmean))\n\n# Summarize using a condition\ndf |&gt;\n  fsummarise(across(is.numeric, # different from dplyr due to across\n                   fmean))\n\n# Modify all the columns\ndf |&gt; \n  fmutate(across(NULL,rev))\n\n# Modify several columns\ndf |&gt; \n  fcomputev(vars = c(\"realf\", \"reald\"), # dropping the other columns\n                  sqrt)\n\ndf &lt;- df |&gt;\n  ftransformv(vars = c(\"realf\", \"reald\"), # keeping the other columns\n                sqrt)\n\ndf &lt;- df |&gt;\n  ftransformv(vars = c(\"realf\", \"reald\"), # reverting for consistency\n                FUN = function(x){ x^2 })\n\n# Modify columns using a condition \n\ndf |&gt;\n  fcomputev(is.numeric,\n           FUN = function(x){x - 1})\n\n\n\n\n# Summarize columns\ndt[, lapply(.SD, mean),\n   .SDcols = c(\"realf\", \"reald\")]\n\n# Summarize using a condition\ndt[, lapply(.SD, mean),\n     .SDcols = is.numeric]\n\n# Modify all the columns\ndt[, lapply(.SD, rev)]\n\n# Modify several columns\ndt[, lapply(.SD, sqrt), # dropping the other columns\n     .SDcols = realf:reald]\n\ncols &lt;- c(\"realf\", \"reald\")\n\ndt[, (cols) := lapply(.SD, sqrt), # keeping the other columns\n     .SDcols = cols]\n\ndt[, (cols) := lapply(.SD, \"^\", 2L), # reverting for consistency\n     .SDcols = cols]\n\n# Modify columns using a condition \ndt[, .SD - 1,\n     .SDcols = is.numeric] \n\nrm(cols)\n\n\n\n\n# Summarize columns\ntb |&gt;\n  summarise(across(c(\"realf\", \"reald\"),\n            mean))\n\n# Summarize using a condition\ntb |&gt;\n  summarise(across(where(is.numeric),\n                   mean))\n\n# Modify all the columns\ntb |&gt; \n  mutate(across(everything(),\n                rev))\n\n# Modify several columns\ntb |&gt;\n  transmute(across(c(\"realf\", \"reald\"), # dropping the other columns\n                  sqrt))\n\ntb &lt;- tb |&gt;\n  mutate(across(all_of(c(\"realf\", \"reald\")), # keeping the other columns\n                sqrt))\n\ntb &lt;- tb |&gt;\n  mutate(across(all_of(c(\"realf\", \"reald\")), # reverting for consistency\n                ~ \"^\"(.x, 2L)))\n\n# Modify columns using a condition \n\ntb |&gt;\n  transmute(across(where(is.numeric), \n                   ~ '-'(., 1L)))\n\n\n\n\n\n\nChain expressions\n\ncollapsedata.tabledplyr\n\n\n\ndf |&gt;\n  fgroup_by(ch)|&gt;\n  fsummarise(sumrf = fsum(realf))|&gt;\n  fsubset(sumrf &lt; 129000)\n\n\n\n\ndt[, by = ch,\n   .(sumrf = sum(realf))][\n     sumrf &lt; 129000\n   ]\n\n\n\n\ntb |&gt;\n  group_by(ch)|&gt;\n  summarise(sumrf = sum(realf))|&gt;\n  filter(sumrf &lt; 129000)\n\n\n\n\n\n\nIndexing and keys (not sure it applies)\n\n\nset modifications\n\ncollapsedata.tabledplyr\n\n\n\n# Replace values (recommendation to use set of data.table)\n\nset(df, i = 1L, j = 2L, value = 30L) \n\n# Reorder rows\n\ndf &lt;- roworder(df, id2, -id1)\n\ndf &lt;- roworder(df, id1) # reversal for consistency\n\n# Modify column names\n\ndf &lt;- frename(df, dt = date)\n\ndf &lt;- frename(df, date = dt) # reversal for consistency\n\n# reorder columns\n\ndf &lt;- colorder(df, id1, id2, ch)\n\n\n\n\n# Replace values\n\nset(dt, i = 1L, j = 2L, value = 30L)\n\n# Reorder rows\n\nsetorder(dt, id2, -id1)\n\nsetorder(dt, id1) # reversal for consistency\n\n# Modify column names\n\nsetnames(dt, old = \"dt\", new = \"date\")\n\nsetnames(dt, old = \"date\", new = \"dt\")  # reversal for consistency\n\n# reorder columns\n\nsetcolorder(dt, c(\"id1\",\"id2\",\"ch\"))\n\n\n\n\n# Replace values\n\ntb[1,2] &lt;- 30L\n\n# Reorder rows\n\ntb &lt;- arrange(tb, id2, desc(id1))\n\ntb &lt;- arrange(tb, id1) # reversal for consistency\n\n# Modify column names\n\ntb &lt;- rename(tb, date = dt)\n\ntb &lt;- rename(tb, dt = date) # reversal for consistency\n\n# reorder columns\n\ntb &lt;- relocate(tb, c(\"id1\", \"id2\", \"ch\"))\n\n\n\n\n\n\nAdvanced use of by (maybe)"
  },
  {
    "objectID": "posts/collapse_cheat_sheet/index.html#joinbind-data-sets",
    "href": "posts/collapse_cheat_sheet/index.html#joinbind-data-sets",
    "title": "Collapse Cheat sheet",
    "section": "Join/Bind data sets",
    "text": "Join/Bind data sets\n\nBind\n\ncollapsedata.tabledplyr\n\n\n\nx &lt;- data.table(1:3)\ny &lt;- data.table(4:6)\nz &lt;- data.table(7:9, 0L)\n\n# bind rows\n\nrowbind(x, y, fill = TRUE) # always fills\n\n# bind rows using a list\n\nrowbind(list(x, y), idcol = \"id\")\n\n# bind columns\n\nbase::cbind(x, y)\n\nadd_vars(x) &lt;- y # modifies x but keeps data structure and attributes\n\n\n\n\nx &lt;- data.table(1:3)\ny &lt;- data.table(4:6)\nz &lt;- data.table(7:9, 0L)\n\n# bind rows\n\nrbind(x, y, fill = TRUE)\n\n# bind rows using a list\n\nrbindlist(list(x, y), idcol = \"id\")\n\n# bind columns\n\nbase::cbind(x, y)\n\nx &lt;- base::cbind(x, y) # modifies x but column names are not changed\n\n\n\n\nx &lt;- data.table(1:3)\ny &lt;- data.table(4:6)\nz &lt;- data.table(7:9, 0L)\n\n# bind rows\n\nbind_rows(x, y) # always fills\n\n# bind rows using a list\n\nbind_rows(list(x, y), .id = \"id\")\n\n# bind columns\n\nbind_cols(x, y)\n\nx &lt;- bind_cols(x, y) # modifies x and replace names"
  },
  {
    "objectID": "posts/collapse_cheat_sheet/index.html#efficient-functions-maybe",
    "href": "posts/collapse_cheat_sheet/index.html#efficient-functions-maybe",
    "title": "Collapse Cheat sheet",
    "section": "Efficient functions (maybe)",
    "text": "Efficient functions (maybe)"
  },
  {
    "objectID": "posts/collapse_cheat_sheet/index.html#other-useful-functions-in-collapse",
    "href": "posts/collapse_cheat_sheet/index.html#other-useful-functions-in-collapse",
    "title": "Collapse Cheat sheet",
    "section": "Other useful functions in collapse",
    "text": "Other useful functions in collapse\n\n# quick summary (From STATA summarize and xtsummarize)\n\nqsu(df, cols = c(\"realf\"))"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "What’s new in PIP?",
    "section": "",
    "text": "Understanding R’s Call Stack: sys.call() and Friends\n\n\n\n\n\n\nR\n\n\nMetaprogramming\n\n\nDebugging\n\n\n\nUnderstanding call stack introspection in R\n\n\n\n\n\nApr 8, 2025\n\n\nR.Andres Castaneda\n\n\n\n\n\n\n\n\n\n\n\n\nHow to Create Robust Argument Checking in R Functions\n\n\n\n\n\n\nR programming\n\n\nBest practices\n\n\n\nCreate a function that checks the arguments of another function\n\n\n\n\n\nMar 25, 2025\n\n\nR.Andres Castaneda\n\n\n\n\n\n\n\n\n\n\n\n\nCollapse Cheat sheet\n\n\n\n\n\n\ncollapse\n\n\ndata.table\n\n\ndplyr\n\n\nefficiency\n\n\n\nSyntax translation from dplyr and data.tablen to collapse\n\n\n\n\n\nMar 13, 2025\n\n\nPIP Technical team\n\n\n\n\n\n\n\n\n\n\n\n\nMastering tryCatch() in R: From Basics to Structured Logging\n\n\n\n\n\n\nR\n\n\nError Handling\n\n\nRobust Code\n\n\n\nLearn how to use tryCatch() in R to handle errors and warnings, recover from failures, and build structured logging systems.\n\n\n\n\n\nFeb 13, 2025\n\n\nDiana C. Garcia\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Cool content about the development of PIP packages"
  },
  {
    "objectID": "posts/Check_args/index.html",
    "href": "posts/Check_args/index.html",
    "title": "How to Create Robust Argument Checking in R Functions",
    "section": "",
    "text": "When developing functions in R, it’s essential to ensure that inputs meet specific criteria. One common and effective practice is creating an auxiliary function dedicated exclusively to validating arguments passed to another function. This approach helps to maintain clean, readable, and robust code."
  },
  {
    "objectID": "posts/Check_args/index.html#why-create-a-separate-argument-checking-function",
    "href": "posts/Check_args/index.html#why-create-a-separate-argument-checking-function",
    "title": "How to Create Robust Argument Checking in R Functions",
    "section": "Why Create a Separate Argument Checking Function?",
    "text": "Why Create a Separate Argument Checking Function?\nSeparating argument checking from your primary function logic provides several benefits:\n\nCode readability: Separating validation logic keeps your main functions concise and easy to understand.\nReusability: Validation logic can often be reused across multiple functions.\nMaintainability: Updating validation rules in one place is simpler and reduces the risk of inconsistencies."
  },
  {
    "objectID": "posts/Check_args/index.html#how-it-works",
    "href": "posts/Check_args/index.html#how-it-works",
    "title": "How to Create Robust Argument Checking in R Functions",
    "section": "How It Works",
    "text": "How It Works\nHere’s a straightforward and effective way to implement argument checking using an auxiliary function."
  },
  {
    "objectID": "posts/Check_args/index.html#practical-example",
    "href": "posts/Check_args/index.html#practical-example",
    "title": "How to Create Robust Argument Checking in R Functions",
    "section": "Practical Example",
    "text": "Practical Example\nBelow is an example demonstrating how one function (goo()) can validate the arguments of another function (foo()):\n\nfoo &lt;- function(x, y = 2, z = \"a\", ...) {\n  # Capture explicitly defined arguments\n  args &lt;- as.list(environment())\n\n  # Capture additional arguments from ...\n  args &lt;- c(args, list(...))\n\n  # Pass args list to goo\n  goo(args)\n}\n\n# Argument checking function\ngoo &lt;- function(args) {\n  # Expand arguments directly into goo's environment\n  list2env(args, envir = environment())\n\n  # Perform validation\n  stopifnot(\n    is.numeric(x),\n    is.numeric(y),\n    is.character(z)\n  )\n\n  # Additional checks for extra arguments in ...\n  if (exists(\"w\")) {\n    stopifnot(is.logical(w))\n  }\n\n  cat(\"All checks passed!\\n\")\n}"
  },
  {
    "objectID": "posts/Check_args/index.html#how-does-this-work",
    "href": "posts/Check_args/index.html#how-does-this-work",
    "title": "How to Create Robust Argument Checking in R Functions",
    "section": "How Does This Work?",
    "text": "How Does This Work?\nLet’s break down the logic:\n\nCapture arguments: The primary function (foo()) captures explicitly defined arguments and the additional arguments passed via the ellipsis (...) into a list.\nPass arguments for checking: The argument list (args) is passed to the auxiliary checking function (goo()).\nExpand and validate arguments: Inside goo(), we expand this list of arguments into its own environment using list2env(). This allows direct reference by their original names.\nArgument checks: We perform validation checks using stopifnot() to ensure each argument meets our criteria."
  },
  {
    "objectID": "posts/Check_args/index.html#examples-of-usage",
    "href": "posts/Check_args/index.html#examples-of-usage",
    "title": "How to Create Robust Argument Checking in R Functions",
    "section": "Examples of Usage",
    "text": "Examples of Usage\nLet’s demonstrate with some examples:\n\n# Example: correct arguments\nfoo(x = 1, y = 3, z = \"test\") # passes validation\n\n# Example: extra argument 'w' correctly specified as logical\nfoo(x = 1, w = TRUE) # passes validation\n\n# Example: incorrect 'x' argument type\nfoo(x = \"wrong\") # triggers error, x is not numeric\n\nError in goo(args): is.numeric(x) is not TRUE\n\n# Example: incorrect additional argument 'w'\nfoo(x = 1, w = \"wrong\") # triggers error, w is not logical\n\nError in goo(args): is.logical(w) is not TRUE"
  },
  {
    "objectID": "posts/Check_args/index.html#benefits-and-best-practices",
    "href": "posts/Check_args/index.html#benefits-and-best-practices",
    "title": "How to Create Robust Argument Checking in R Functions",
    "section": "Benefits and Best Practices",
    "text": "Benefits and Best Practices\n\nAlways clearly define your argument types and validations.\nCentralize your argument checking logic for consistency.\nConsider reusing or extending your argument checking function (goo()) for similar functions.\n\nAdopting this pattern greatly enhances your R programming practice by ensuring robustness, clarity, and efficiency."
  },
  {
    "objectID": "posts/Excp_Hndl/index.html",
    "href": "posts/Excp_Hndl/index.html",
    "title": "Exception Handling",
    "section": "",
    "text": "The following is an example of how to use exception handling in R within the PIP pipeline. In particular, I focus on using tryCatch . This is a simplifies example from what we used on the cleaning process in pipdata."
  },
  {
    "objectID": "posts/Excp_Hndl/index.html#load-libraries-and-functions",
    "href": "posts/Excp_Hndl/index.html#load-libraries-and-functions",
    "title": "Exception Handling",
    "section": "Load libraries and functions",
    "text": "Load libraries and functions\nFirst, these are the main libraries needed.\n\n# Load libraries \nlibrary(metapip) \nlibrary(data.table)\nlibrary(pipload)\n\nHowever, make sure to have installed the following packages as well: cli and rlang .\nThe following is the example of the function we need to be “handle” with tryCatch. This function tries to check if there are duplicates in dt according to some keyVar and if there are duplicates it can abort and exit or continue without exiting and logging the error. The function has another two parameters to decide the following:\n\nlog_err if we want the error to be included in a error-report log.\nskip_err if we want the error to be skipped or not.\n\n\n# Function to handle duplicated observations in pfw \nunq_pfw &lt;- function(dt,\n                    keyVar,\n                    log_err = TRUE,\n                    skip_err = TRUE){   \n  tryCatch(      \n    expr = {        \n      if(uniqueN(dt, by = keyVar) != nrow(dt)){          \n        dt_d &lt;- dt[duplicated(dt, by = keyVar)]         \n        n_rep &lt;- nrow(dt_d)          \n        cli::cli_abort(message = \"There {?is/are} {n_rep} duplicates in `pfw`\",\n                       class = c(\"dup_pfw\", \"piperr\"),\n                       log = log_err,\n                       skip = skip_err,\n                       link =  unique(dt_d$link),\n                       call = sys.call())       \n        }      \n      },      \n    dup_pfw = function(cnd){        \n      if(cnd$log){ \n        # Log the error          \n        add_log(cnd)        \n      }        \n      if(!cnd$skip){ \n        # Abort if you don't want to skip, but after logging          \n        cli::cli_abort(cnd$message, call = cnd$call)        \n      }\n      },\n    error = function(cnd){\n      # Abort for unknown error\n      cli::cli_abort(\"Unknown Error\", call = cnd$call)\n    },      \n    finally = {        \n      dt &lt;- unique(dt, by = keyVar) # eliminate duplicates      \n    }    \n  )   \n  \n  return(dt) \n  \n  }\n\nIf you run the lines within expr ={ }, this will probably crash and an error about duplicates will be shown. However, what we want is to first record this error on a log, and then decide if to skip the error or not, and get a clean dataset. Also, if there was another error within expr ={ }, the function will not log the error, it will stop the process and warn of an “Unknown Error”. That is why we need tryCatch. As you can see within the finally section, we also included a line that eliminates the duplicates and returns the new “clean” data set.\nThis is how tryCatch works in our example: First, within the parameters of cli::cli_abort(), message works as expected. However, class might be the most important to describe. The class we give to this specific error, or condition, will be what makes it identifiable on our tryCatch. Since we gave a new class to the error called dup_pfw, the function tryCatch, instead of aborting and exiting the code when the error is found, will run the code within dup_pfw = function(cnd){ } instead. The parameter cnd then carries all the information we gave within cil::cli_abort; the class, the log/skip actions, and the identifiers of the duplicates called link .\nImportant: The parameters log and skip within cil::cli_abort are the tools we use to handle this error and these are totally made up for this specific function. You can create any parameter you want within cli::abort() and this will carry on within the handler. For example, the parameter link will carry the identifiers of those duplicated observations, which are needed for the error-report log.\nRegarding the log, before running the code below, we need to load the following function add_log. This function will load some concatenated text on the file log.txt saved in the working directory and it is used within the handler.\n\n# Function for logging \nadd_log &lt;- function(cnd) {    \n  cat(\"[\", class(cnd)[[1]], \"-\", class(cnd)[[2]], \"] \",     \n      cnd$message,\" for \",     \n      cnd$link, \"\\n\", sep = \"\",     \n      file = \"log.txt\", append = TRUE)  \n  }"
  },
  {
    "objectID": "posts/Excp_Hndl/index.html#load-data-and-run-code",
    "href": "posts/Excp_Hndl/index.html#load-data-and-run-code",
    "title": "Exception Handling",
    "section": "Load data and run code",
    "text": "Load data and run code\nThe data we will use for this example can be loaded with pipload and represents the auxiliary Price Frame Work, or pfw. Since we need to run over the error at some point, we have to create another data frame with some duplicates, pfw_d .\n\n# Load data \npfw_t &lt;- pip_load_aux(\"pfw\")  \n\nv Most recent version of data loaded:\n'pfw.qs'\n\n\ni no labels available for measure pfw\n\npfw_d &lt;- rbind(pfw_t, pfw_t[rep(1, 5), ]) # Duplicate some rows from one country\n\nNow, we will run the function and this should not give any errors because the default value is skip_err = TRUE .\n\n# Run tryCatch for unq_pwf function \nkeyVar &lt;- c(\"country_code\", \"surveyid_year\", \"survey_acronym\")  \npfw &lt;- unq_pfw(pfw_d, keyVar)\n\nIf the error was handled and skipped correctly, according to the default parameters, the answer to the following code should give you TRUE and you will find a log.txt file with the new record of these error.\n\n# Test  \nuniqueN(pfw, by = keyVar) == nrow(pfw)\n\n[1] TRUE\n\n\nHowever, if you run the function without skipping the error, the abort function will come into action:\n\n# Run tryCatch for unq_pwf function without skipping error  \npfw &lt;- unq_pfw(pfw_d, keyVar, skip_err = FALSE)\n\nError in `unq_pfw()`:\n! Unknown Error"
  },
  {
    "objectID": "posts/Excp_Hndl/index.html#sources",
    "href": "posts/Excp_Hndl/index.html#sources",
    "title": "Exception Handling",
    "section": "Sources",
    "text": "Sources\nA few websites I reviewed to learned more about this:\n\nhttps://adv-r.hadley.nz/conditions.html#conditions\nhttps://medium.com/number-around-us/catch-me-if-you-can-exception-handling-in-r-2e0f6c473a28\nhttps://cnuge.github.io/post/trycatch/\nhttps://aryoda.github.io/tutorials/tryCatchLog/tryCatchLog-intro-slides.html#/ (still reviewing it)"
  },
  {
    "objectID": "posts/Excp_Hndl/index.html#work-in-progress",
    "href": "posts/Excp_Hndl/index.html#work-in-progress",
    "title": "Exception Handling",
    "section": "Work in progress…",
    "text": "Work in progress…\nA few things I am still figuring/working out are:\n\nI still have to format the add_log function to allowed for more than one character on the cnd$link value, or to make it more general so it can be used in other handlers."
  },
  {
    "objectID": "AdvR.html",
    "href": "AdvR.html",
    "title": "Advance R Sessions",
    "section": "",
    "text": "Condition Handling\n\n\nAdvance R Session 1\n\n\n\n\n\n\n\n\nDiana Garcia\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "presentations/Exp_Hand/index.html",
    "href": "presentations/Exp_Hand/index.html",
    "title": "Condition Handling",
    "section": "",
    "text": "Conditions\n\nErrors (severe): function should not continue\nWarnings (mild): something went wrong but it will continue\nMessages (mildest): inform the user of an action taken\n\nSignals of conditions\n\nstop() or rlang::abort(),\nwarning() or rlang::warn(),\nmessage()\n\n\n\n\n\n\n\n\nError:\n\nWe need the process to stop.\nMessage should indicate what is wrong and where to fix the problem.\n\nWarning:\n\nWarn of an issue and let the process continue.\nThese can be many per function and will be displayed in aggregate.\nMessage like important change was done or missing info was found.\nBetter not to overuse it.\n\nMessages:\n\nUsually when something is done on the behalf of the user\nE.g. A default value was used or the progress on a long process.\nBetter not to have many messages per function. They are immediately displayed.\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion:\n\n\n\nAny ideas on where we can make use of these conditions within our pipeline?"
  },
  {
    "objectID": "presentations/Exp_Hand/index.html#important-concepts",
    "href": "presentations/Exp_Hand/index.html#important-concepts",
    "title": "Condition Handling",
    "section": "",
    "text": "Conditions\n\nErrors (severe): function should not continue\nWarnings (mild): something went wrong but it will continue\nMessages (mildest): inform the user of an action taken\n\nSignals of conditions\n\nstop() or rlang::abort(),\nwarning() or rlang::warn(),\nmessage()"
  },
  {
    "objectID": "presentations/Exp_Hand/index.html#when-to-use",
    "href": "presentations/Exp_Hand/index.html#when-to-use",
    "title": "Condition Handling",
    "section": "",
    "text": "Error:\n\nWe need the process to stop.\nMessage should indicate what is wrong and where to fix the problem.\n\nWarning:\n\nWarn of an issue and let the process continue.\nThese can be many per function and will be displayed in aggregate.\nMessage like important change was done or missing info was found.\nBetter not to overuse it.\n\nMessages:\n\nUsually when something is done on the behalf of the user\nE.g. A default value was used or the progress on a long process.\nBetter not to have many messages per function. They are immediately displayed."
  },
  {
    "objectID": "presentations/Exp_Hand/index.html#pip-pipeline",
    "href": "presentations/Exp_Hand/index.html#pip-pipeline",
    "title": "Condition Handling",
    "section": "",
    "text": "Question:\n\n\n\nAny ideas on where we can make use of these conditions within our pipeline?"
  },
  {
    "objectID": "presentations/Exp_Hand/index.html#ignoring-conditions",
    "href": "presentations/Exp_Hand/index.html#ignoring-conditions",
    "title": "Condition Handling",
    "section": "Ignoring conditions",
    "text": "Ignoring conditions\nUnpopular opinion:\n\nSimplest way to handling conditions is to ignore them!"
  },
  {
    "objectID": "presentations/Exp_Hand/index.html#ignoring-conditions-1",
    "href": "presentations/Exp_Hand/index.html#ignoring-conditions-1",
    "title": "Condition Handling",
    "section": "Ignoring conditions",
    "text": "Ignoring conditions\nExample on try():\n\nWithoutWithSilent\n\n\n\nf1 &lt;- function(x) {\n  log(x)\n  10\n}\n\nf1(\"x\")\n\nError in log(x): non-numeric argument to mathematical function\n\n\n\n\n\nf2 &lt;- function(x) {\n  try(log(x))\n  10\n}\n\nf2(\"a\")\n\nError in log(x) : non-numeric argument to mathematical function\n\n\n[1] 10\n\n\n\n\n\nf2 &lt;- function(x) {\n  try(log(x), silent = TRUE)\n  10\n}\n\nf2(\"a\")\n\n[1] 10"
  },
  {
    "objectID": "presentations/Exp_Hand/index.html#ignoring-conditions-2",
    "href": "presentations/Exp_Hand/index.html#ignoring-conditions-2",
    "title": "Condition Handling",
    "section": "Ignoring conditions",
    "text": "Ignoring conditions\nOther ignoring conditions are:\n\nsuppressWarnings()\nsuppressMessages()"
  },
  {
    "objectID": "presentations/Exp_Hand/index.html#handling-conditions",
    "href": "presentations/Exp_Hand/index.html#handling-conditions",
    "title": "Condition Handling",
    "section": "Handling conditions",
    "text": "Handling conditions\nWe can override or supplement the default behavior using:\n\ntryCatch()\nwithCallingHandlres()"
  },
  {
    "objectID": "presentations/Exp_Hand/index.html#trycatch",
    "href": "presentations/Exp_Hand/index.html#trycatch",
    "title": "Condition Handling",
    "section": "tryCatch",
    "text": "tryCatch\nIt is used for exiting handlers and more suitable for errors.\n\ntryCatch(\n  \n  error = function(cnd) {\n    # code to run when error is thrown\n  },\n  \n  expr = {\n    code_to_run_while_handlers_are_active\n  }\n  \n)\n\nWhen condition is handled it returns to where tryCatch was called."
  },
  {
    "objectID": "presentations/Exp_Hand/index.html#withcallinghandlers",
    "href": "presentations/Exp_Hand/index.html#withcallinghandlers",
    "title": "Condition Handling",
    "section": "withCallingHandlers",
    "text": "withCallingHandlers\nIt is used for calling handlers and more suitable for non-errors conditions.\n\nwithCallingHandlers(\n  \n  warning = function(cnd) {\n    # code to run when warning is signalled\n  },\n  \n  message = function(cnd) {\n    # code to run when message is signalled\n  },\n  \n  expr = {\n    code_to_run_while_handlers_are_active\n  }\n)\n\nAfter condition is captured, it returns where the condition was signaled."
  },
  {
    "objectID": "presentations/Exp_Hand/index.html#exiting-conditions",
    "href": "presentations/Exp_Hand/index.html#exiting-conditions",
    "title": "Condition Handling",
    "section": "Exiting conditions",
    "text": "Exiting conditions\nWe could override the default error\n\nf3 &lt;- function(x) {\n  tryCatch(\n    \n    error = function(cnd) \n      NA,\n    \n    expr = {\n      log(x)\n    }\n    \n  )\n}\n\nf3(\"x\")\n\n[1] NA"
  },
  {
    "objectID": "presentations/Exp_Hand/index.html#exiting-conditions-1",
    "href": "presentations/Exp_Hand/index.html#exiting-conditions-1",
    "title": "Condition Handling",
    "section": "Exiting conditions",
    "text": "Exiting conditions\ntryCatch exits once the condition is signaled:\n\nSignalNo signal\n\n\n\ntryCatch(\n  \n  message = function(cnd) \n    \"There\",\n  \n  expr = {\n    message(\"Here\")\n    stop(\"This code is never run!\")\n  }\n)\n\n[1] \"There\"\n\n\n\n\n\ntryCatch(\n  \n  error = function(cnd) \n    10,\n  \n  expr = {\n    message(\"Hi!\")\n    1 + 1\n  }\n)\n\nHi!\n\n\n[1] 2"
  },
  {
    "objectID": "presentations/Exp_Hand/index.html#calling-conditions",
    "href": "presentations/Exp_Hand/index.html#calling-conditions",
    "title": "Condition Handling",
    "section": "Calling conditions",
    "text": "Calling conditions\nThey help signal a problem and the code execution continues normally.\n\nwithCallingHandlers(\n  \n  message = function(cnd) \n    cat(\"Caught a message!\\n\"), \n  \n  expr = {\n    message(\"Someone there?\")\n    message(\"Why, yes!\")\n  }\n)\n\nCaught a message!\n\n\nSomeone there?\n\n\nCaught a message!\n\n\nWhy, yes!\n\n\nNotice: They are applied in order."
  },
  {
    "objectID": "presentations/Exp_Hand/index.html#conditon-objects",
    "href": "presentations/Exp_Hand/index.html#conditon-objects",
    "title": "Condition Handling",
    "section": "Conditon objects",
    "text": "Conditon objects\nBehind the scenes, objects are created when signaling a condition.\n\ncnd &lt;- rlang::catch_cnd(stop(\"An error\"))\n\nstr(cnd)\n\nList of 2\n $ message: chr \"An error\"\n $ call   : language force(expr)\n - attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\n\nWe can access the elements of this object using:\n\ncondtionMessage()\nconditionCall()"
  },
  {
    "objectID": "presentations/Exp_Hand/index.html#other-topics-about-conditions",
    "href": "presentations/Exp_Hand/index.html#other-topics-about-conditions",
    "title": "Condition Handling",
    "section": "Other topics about conditions",
    "text": "Other topics about conditions\n\nThey can be nested -&gt; muffle the signal\nCall stacks -&gt; error catching or debugging\n\nIf you want to learn more about them, check Advanced R’s 8.4.3 and 8.4.4 subsections!"
  },
  {
    "objectID": "presentations/Exp_Hand/index.html#motivation",
    "href": "presentations/Exp_Hand/index.html#motivation",
    "title": "Condition Handling",
    "section": "Motivation",
    "text": "Motivation\n\nPrice Framework data (PFW) is the ‘metadata’ behind each survey in Dataliweb (DLW).\nImportant: for each specific survey we should have only one record (or row/observation).\n\n\n\n\n\n\n\nObjective:\n\n\n\n\nSignal if there are duplicates of PFW per country_code,surveyid_year and survey_acronym.\nLog which are the duplicates\nAnd continue with the process using only unique values.\n\n\n\nLet’s see structure of PFW…"
  },
  {
    "objectID": "presentations/Exp_Hand/index.html#what-to-do",
    "href": "presentations/Exp_Hand/index.html#what-to-do",
    "title": "Condition Handling",
    "section": "What to do?",
    "text": "What to do?\n\n# Function to handle duplicated observations in pfw \nunq_pfw &lt;- function(dt,                     \n                    keyVar) {    \n    tryCatch(      \n    expr = {   \n      \n      \"???\"\n        \n    },\n    \n    error = function(cnd){\n      \n      \"???\"\n        \n    }  \n    )     \n  \n  return(dt)  \n}"
  },
  {
    "objectID": "presentations/Exp_Hand/index.html#toy-solution",
    "href": "presentations/Exp_Hand/index.html#toy-solution",
    "title": "Condition Handling",
    "section": "Toy solution",
    "text": "Toy solution\n\nDon’t stop process:\n\n\n# Function to handle duplicated observations in pfw\nunq_pfw &lt;- function(dt,\n                    keyVar){\n\n  if(data.table::uniqueN(dt, by = keyVar) != nrow(dt)){\n\n    tryCatch(\n      expr = {\n\n        cli::cli_abort()\n\n      },\n      error = function(cnd){\n\n        message(\"There are duplicates in `pfw`\")\n\n      }\n    )\n\n    dt &lt;- unique(dt, by = keyVar)\n  }\n  return(dt)\n}"
  },
  {
    "objectID": "presentations/Exp_Hand/index.html#result",
    "href": "presentations/Exp_Hand/index.html#result",
    "title": "Condition Handling",
    "section": "Result",
    "text": "Result\n\n#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n# Load Libraries   ---------\nlibrary(rlang)\n\nWarning: package 'rlang' was built under R version 4.3.3\n\n\n\n#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n# Load data  ---------\n\npfw &lt;- pipload::pip_load_aux(\"pfw\")\n\nv Most recent version of data loaded:\n'pfw.qs'\n\n\ni no labels available for measure pfw\n\nkeyVar &lt;- c(\"country_code\",\n            \"surveyid_year\",\n            \"survey_acronym\")\n\n\n#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n# Duplicate one value    ---------\n\npfw_d &lt;- rbind(pfw, pfw[rep(1, 5), ])\n\n#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n# Use function  ---------\n\npfw_f &lt;- unq_pfw(pfw_d, keyVar)\n\nThere are duplicates in `pfw`\n\n\nBut the message is not that informative and what if I want to stop at any error?"
  },
  {
    "objectID": "presentations/Exp_Hand/index.html#signaling-and-handling",
    "href": "presentations/Exp_Hand/index.html#signaling-and-handling",
    "title": "Condition Handling",
    "section": "Signaling and Handling",
    "text": "Signaling and Handling\n\nLet’s use the condition object\n\n\n# Function to handle duplicated observations in pfw\nunq_pfw &lt;- function(dt,\n                    keyVar){\n\n  if(data.table::uniqueN(dt, by = keyVar) != nrow(dt)){\n\n    tryCatch(\n      expr = {\n        \n        dt_d &lt;- dt[duplicated(dt, by = keyVar)]         \n        n_rep &lt;- nrow(dt_d)          \n        cli::cli_abort(message = \"There {?is/are} {n_rep} duplicates in `pfw`\",\n                       class = c(\"piperr\"),\n                       link =  unique(dt_d$link))\n\n      },\n      piperr = function(cnd){\n\n        msg &lt;- cat(\"[\", class(cnd)[[1]], \"] \",\n            cnd$message,\" for \", cnd$link, \"\\n\", sep = \"\")\n        \n        message(msg)\n\n      }\n    )\n\n    dt &lt;- unique(dt, by = keyVar)\n  }\n  return(dt)\n}"
  },
  {
    "objectID": "presentations/Exp_Hand/index.html#result-1",
    "href": "presentations/Exp_Hand/index.html#result-1",
    "title": "Condition Handling",
    "section": "Result",
    "text": "Result\n\n#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n# Load data  ---------\n\npfw &lt;- pipload::pip_load_aux(\"pfw\")\n\nv Most recent version of data loaded:\n'pfw.qs'\n\n\ni no labels available for measure pfw\n\nkeyVar &lt;- c(\"country_code\",\n            \"surveyid_year\",\n            \"survey_acronym\")\n\n\n#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n# Duplicate one value    ---------\n\npfw_d &lt;- rbind(pfw, pfw[rep(1, 5), ])\n\n#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n# Use function  ---------\n\npfw_f &lt;- unq_pfw(pfw_d, keyVar)\n\n[piperr] There are 5 duplicates in `pfw` for AUS_1981_IHS-LIS\n\n\n\n\n\nBut what if I don’t want it to be skipped?"
  },
  {
    "objectID": "presentations/Exp_Hand/index.html#handling-1",
    "href": "presentations/Exp_Hand/index.html#handling-1",
    "title": "Condition Handling",
    "section": "Handling",
    "text": "Handling\n\nLet’s add another argument\n\n\n# Function to handle duplicated observations in pfw\nunq_pfw &lt;- function(dt,\n                    keyVar,                    \n                    skip_err = TRUE){\n\n  if(data.table::uniqueN(dt, by = keyVar) != nrow(dt)){\n\n    tryCatch(\n      expr = {\n        \n        dt_d &lt;- dt[duplicated(dt, by = keyVar)]         \n        n_rep &lt;- nrow(dt_d)          \n        cli::cli_abort(message = \"There {?is/are} {n_rep} duplicates in `pfw`\",\n                       class = c(\"piperr\"),\n                       skip = skip_err,\n                       link =  unique(dt_d$link),\n                       call = sys.call())\n        },\n      piperr = function(cnd){\n\n      msg &lt;- cat(\"[\", class(cnd)[[1]], \"] \",\n            cnd$message,\" for \", cnd$link, \"\\n\", sep = \"\")\n        \n        message(msg)\n        \n      if(!cnd$skip){\n        # Abort if you don't want to skip, but after logging\n        cli::cli_abort(cnd$message, \n                       call = cnd$call)\n      }\n        \n        } \n    )\n\n    dt &lt;- unique(dt, by = keyVar)\n  \n    }\n  return(dt)\n}"
  },
  {
    "objectID": "presentations/Exp_Hand/index.html#my-solution",
    "href": "presentations/Exp_Hand/index.html#my-solution",
    "title": "Condition Handling",
    "section": "My solution",
    "text": "My solution\n\n# Function to handle duplicated observations in pfw\nunq_pfw &lt;- function(dt,\n                    keyVar,                     \n                    log_err = TRUE,                     \n                    skip_err = TRUE){\n\n    tryCatch(\n      expr = {\n        \n        if(data.table::uniqueN(dt, by = keyVar) != nrow(dt)){\n        \n        dt_d &lt;- dt[duplicated(dt, by = keyVar)]         \n        n_rep &lt;- nrow(dt_d)          \n        cli::cli_abort(message = \"There {?is/are} {n_rep} duplicates in `pfw`\",\n                       class = c(\"dup_pfw\", \"piperr\"),\n                       log = log_err,\n                       skip = skip_err,\n                       link =  unique(dt_d$link),\n                       call = sys.call())\n        \n        }\n        \n        },\n      error = function(cnd){\n        \n        cli::cli_abort(message = \"Untracked error\",\n                       call = cnd$call)\n        \n      },\n      dup_pfw = function(cnd){\n        \n      if(cnd$log){ \n        # Log the error\n        add_log(cnd)\n      }\n      \n      if(!cnd$skip){\n        # Abort if you don't want to skip, but after logging\n        cli::cli_abort(cnd$message, \n                       call = cnd$call)\n      }\n        \n        },  \n      \n      finally = {\n        \n      dt &lt;- unique(dt, by = keyVar)\n      \n      } \n    )\n    \n  return(dt)\n}"
  },
  {
    "objectID": "presentations/Exp_Hand/index.html#other-applications",
    "href": "presentations/Exp_Hand/index.html#other-applications",
    "title": "Condition Handling",
    "section": "Other applications",
    "text": "Other applications\n\nSuccess and failure values:\n\nReturn a value for success and another for failure.\n\nResignal and record\n\nMore informative error messages and record for later investigation\n\nNo default behavior:\n\nUsing signal() you can create a condition different from a error,warning or message."
  }
]