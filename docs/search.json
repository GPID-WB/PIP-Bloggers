[
  {
    "objectID": "posts/SysCall/index.html",
    "href": "posts/SysCall/index.html",
    "title": "Understanding R’s Call Stack: sys.call() and Friends",
    "section": "",
    "text": "If you’ve ever wanted an R function to know who called it, inspect its own body, or adapt based on where it’s running, then you’re looking for call stack introspection — and functions like sys.call(), sys.parent(), and sys.function() are your best tools.\nIn this post, we’ll demystify these powerful functions, showing how they allow you to:\n\nTrack who called a function (sys.parent())\nSee how it was called (sys.call())\nAccess the actual function object being executed (sys.function())\n\nWe’ll also take a brief look at formals(), body() and environment() — three essential tools for inspecting a function’s signature and its defining environment.\nUnderstanding these functions isn’t just for advanced metaprogramming — they’re incredibly useful for logging, debugging, writing wrappers, building APIs, or just making your code more transparent and robust.\nLet’s get started with a minimal example of how the call stack works in R."
  },
  {
    "objectID": "posts/SysCall/index.html#introduction",
    "href": "posts/SysCall/index.html#introduction",
    "title": "Understanding R’s Call Stack: sys.call() and Friends",
    "section": "",
    "text": "If you’ve ever wanted an R function to know who called it, inspect its own body, or adapt based on where it’s running, then you’re looking for call stack introspection — and functions like sys.call(), sys.parent(), and sys.function() are your best tools.\nIn this post, we’ll demystify these powerful functions, showing how they allow you to:\n\nTrack who called a function (sys.parent())\nSee how it was called (sys.call())\nAccess the actual function object being executed (sys.function())\n\nWe’ll also take a brief look at formals(), body() and environment() — three essential tools for inspecting a function’s signature and its defining environment.\nUnderstanding these functions isn’t just for advanced metaprogramming — they’re incredibly useful for logging, debugging, writing wrappers, building APIs, or just making your code more transparent and robust.\nLet’s get started with a minimal example of how the call stack works in R."
  },
  {
    "objectID": "posts/SysCall/index.html#a-minimal-example-of-a-call-stack",
    "href": "posts/SysCall/index.html#a-minimal-example-of-a-call-stack",
    "title": "Understanding R’s Call Stack: sys.call() and Friends",
    "section": "A Minimal Example of a Call Stack",
    "text": "A Minimal Example of a Call Stack\nLet’s define three simple functions:\n\nbaz &lt;- function() {\n  print(\"Inside baz()\")\n  print(sys.call())\n  print(sys.parent()) \n}\n\nbar &lt;- function() {\n  print(\"Inside bar()\")\n  baz()\n}\n\nfoo &lt;- function() {\n  print(\"Inside foo()\")\n  bar()\n}\n\nfoo()\n\n[1] \"Inside foo()\"\n[1] \"Inside bar()\"\n[1] \"Inside baz()\"\nbaz()\n[1] 31\n\n\nLet’s focus on the last number. What does it mean?\n\nsys.parent() is just a number\nThe function sys.parent() doesn’t return a function or a call — it returns a number. That number is an index into R’s call stack — the internal list of active function calls.\nIn our example, this is the call stack when baz() is executing:\n2: bar()\n1: foo()\n0: global environment\nSo when baz() calls sys.parent(), it gets the index of its direct caller (bar()), which happens to be at position 2 in the stack. If you want to see what that parent call was, you’d need to call sys.call(sys.parent()). But that is not what you see here.\n\n\nWhy is sys.parent() = 2 in the console, but 31 (or another number) in a Quarto document?\nWhen you run this code interactively in R, the call stack is shallow: you’re at the top-level environment (frame 0), and your functions are being called directly.\nBut when you render a Quarto document, things change. Your code is being executed within internal functions used by Quarto and knitr. So your simple foo() call is actually wrapped in 30+ layers of function calls. That’s why sys.parent() might return something like 31.\nSo even though it feels like you’re calling foo(), you’re actually calling something like:\nquarto::render -&gt; knitr::knit -&gt; evaluate::evaluate -&gt; ... -&gt; foo()\n\n\n\n\n\n\nThe takeaway?\n\n\n\nThe value returned by sys.parent() is always relative to the current call stack. Don’t assume it’s fixed — it depends on the context where your code runs.\n\n\nThis is especially important when writing packages or code that might run inside knitr, shiny, testthat, or other frameworks."
  },
  {
    "objectID": "posts/SysCall/index.html#sys.call-what-was-the-actual-call",
    "href": "posts/SysCall/index.html#sys.call-what-was-the-actual-call",
    "title": "Understanding R’s Call Stack: sys.call() and Friends",
    "section": "sys.call() – What Was the Actual Call?",
    "text": "sys.call() – What Was the Actual Call?\nsys.call() returns the actual call expression that invoked the current frame.\nTo trace the current call and the parent call:\n\nbaz &lt;- function() {\n  cat(\"I'm in:\", as.character(sys.call()), \"\\n\")\n  cat(\"I was called by:\", as.character(sys.call(sys.parent())), \"\\n\")\n}\nbar &lt;- \\() {\n  cat(\"I'm bar() and I will call baz()\\n\")\n  baz()\n}\n\n# When baz() is called directly, it is its own parent\nbaz()\n\nI'm in: baz \nI was called by: baz \n\n# when bar() is called, bar() is the parent of baz()\nbar()\n\nI'm bar() and I will call baz()\nI'm in: baz \nI was called by: bar"
  },
  {
    "objectID": "posts/SysCall/index.html#sys.parent-whos-your-caller",
    "href": "posts/SysCall/index.html#sys.parent-whos-your-caller",
    "title": "Understanding R’s Call Stack: sys.call() and Friends",
    "section": "sys.parent() – Who’s Your Caller?",
    "text": "sys.parent() – Who’s Your Caller?\nIf you want to know who called the current function, use sys.parent():\n\ngoo &lt;- function() {\n  parent &lt;- sys.parent()\n  cat(\"Parent frame index:\", parent, \"\\n\")\n  cat(\"Parent call:\", as.character(sys.call(parent)), \"\\n\")\n}\n\nfoo &lt;- function(x) {\n  goo()\n}\n\nfoo()\n\nParent frame index: 30 \nParent call: foo"
  },
  {
    "objectID": "posts/SysCall/index.html#use-case-identifying-the-calling-function-for-errors-and-logs",
    "href": "posts/SysCall/index.html#use-case-identifying-the-calling-function-for-errors-and-logs",
    "title": "Understanding R’s Call Stack: sys.call() and Friends",
    "section": "Use case: Identifying the Calling Function (for Errors and Logs)",
    "text": "Use case: Identifying the Calling Function (for Errors and Logs)\nKnowing the name of the function that called you can be genuinely useful — especially for writing descriptive error messages, debugging tools, or custom logging systems.\nImagine you’re building a helper function that will be used in multiple places across your codebase, and you want to alert the user exactly where something went wrong.\nHere’s a simplified example:\n\nvalidate_input &lt;- function(x) {\n  if (missing(x)) {\n    caller &lt;- as.character(sys.call(sys.parent()))[1]\n    stop(sprintf(\"Function '%s' was called without a required argument 'x'\", caller))\n  }\n}\n\nNow we can call this helper from other functions:\n\nfoo &lt;- function(x) {\n  validate_input(x)\n  # Do something with x\n}\n\n# Try running it without x\nfoo()\n\nError in validate_input(x): Function 'foo' was called without a required argument 'x'\n\n\nThis becomes very powerful when writing frameworks, internal utilities, or packages where you want reusable components to report context-aware messages.\nYou can even take it further and include the full call expression of the parent:\n\nvalidate_input &lt;- function(x) {\n  if (missing(x)) {\n    call_expr &lt;- deparse(sys.call(sys.parent()))\n    stop(sprintf(\"Invalid call: %s — missing argument 'x'\", call_expr))\n  }\n}\n\nbar &lt;- function(x, y = 4, z = \"hola\") {\n  validate_input(x)\n}\n\nbar(y = 3, z = 8)\n\nError in validate_input(x): Invalid call: bar(y = 3, z = 8) — missing argument 'x'\n\n# if you don't call arguments, they won't be shown\n# even if they have defaults... \n# `sys.call(sys.parent())` shows exactly how it was called.\nbar()\n\nError in validate_input(x): Invalid call: bar() — missing argument 'x'\n\n\nThis pattern is especially helpful when writing functions that will be used by other developers or in larger pipelines, where it’s not always obvious where something failed.\n\n\n\n\n\n\nTip\n\n\n\nUse sys.call(sys.parent()) when you want to report errors as if they came from the caller, not the helper.\n\n\nNow that we’ve explored who called a function and how, let’s go one step deeper — and ask: what is this function we’re inside of?"
  },
  {
    "objectID": "posts/SysCall/index.html#sys.function-which-function-is-running",
    "href": "posts/SysCall/index.html#sys.function-which-function-is-running",
    "title": "Understanding R’s Call Stack: sys.call() and Friends",
    "section": "sys.function() – Which Function Is Running?",
    "text": "sys.function() – Which Function Is Running?\nWhile sys.call() tells you how a function was invoked, sys.function() tells you which function object is actually being executed in a specific frame.\nThis allows you to programmatically access and inspect a function’s:\n\nFormal arguments (its signature) via formals()\nBody (its actual code) via body()\nEnvironment (its context) via environment()\n\n\nExample: Inspecting the Current Function\n\ngoo &lt;- function(x = 42) {\n  fun &lt;- sys.function()            # The actual function object being run\n  cat(\"Function signature:\\n\")\n  print(formals(fun))             # What are the arguments?\n  cat(\"\\nFunction body:\\n\")\n  print(body(fun))                # What's the code inside?\n  cat(\"\\nFunction environment:\\n\")\n  print(environment(fun))         # Where was it defined?\n}\n\ngoo()\n\nFunction signature:\n$x\n[1] 42\n\n\nFunction body:\n{\n    fun &lt;- sys.function()\n    cat(\"Function signature:\\n\")\n    print(formals(fun))\n    cat(\"\\nFunction body:\\n\")\n    print(body(fun))\n    cat(\"\\nFunction environment:\\n\")\n    print(environment(fun))\n}\n\nFunction environment:\n&lt;environment: R_GlobalEnv&gt;\n\n\nThis triple combo gives you full programmatic access to the function’s internals.\n\n\nLooking Up the Caller Function\nYou can also use sys.function(sys.parent()) to inspect the function that called you.\n\ngoo &lt;- function() {\n  caller_fun &lt;- sys.parent() |&gt; \n    sys.function()\n  parent_fun &lt;- sys.parent() |&gt; \n    sys.call() |&gt; \n    as.character()  # this is important to be displayed by cat()\n  fun        &lt;- as.character(sys.call())\n  \n  cat(\"I'm\", fun, \"\\n\")\n  cat(\"I was called by\", parent_fun, \"\\n\")\n  cat(\"whose rocking body looks like this:\\n\") # I could not resist the bad joke... sorry\n  print(body(caller_fun))\n  cat(\"Caller function formals (or arguments):\\n\")\n  print(formals(caller_fun))\n  cat(\"Caller function environment:\\n\")\n  print(environment(caller_fun))\n}\n\nfoo &lt;- function(a = 1, b = 2) {\n  goo()\n}\n\nfoo()\n\nI'm goo \nI was called by foo \nwhose rocking body looks like this:\n{\n    goo()\n}\nCaller function formals (or arguments):\n$a\n[1] 1\n\n$b\n[1] 2\n\nCaller function environment:\n&lt;environment: R_GlobalEnv&gt;\n\n\nThis outputs the body, signature, and environment of foo() — the caller of goo().\n\n\nReal Use Case: Dynamic Function Logging\nSuppose you want to create a universal logger that tells you what function is running, how it was called, and from where:\n\nlog_context &lt;- function(y = \"hola\") {\n  this_fun &lt;- sys.function()\n  this_call &lt;- sys.call()\n  caller_call &lt;- sys.call(sys.parent())\n\n  cat(\"You are in function:\\n\")\n  print(this_call)\n  cat(\"Formal arguments:\\n\")\n  print(formals(this_fun))\n  cat(\"Called by:\\n\")\n  print(caller_call)\n}\n\nwrap_me &lt;- function(x = 10) {\n  # `x` is to used in other parts of `wrap_me()`\n  log_context()\n}\n\nwrap_me()\n\nYou are in function:\nlog_context()\nFormal arguments:\n$y\n[1] \"hola\"\n\nCalled by:\nwrap_me()\n\n\nThis allows meta-level logging, introspection, or debugging, especially when used inside package utilities, decorators, or dynamic wrappers.\n\n\nFinal Thoughts on sys.function()\n\n\n\nTool\nWhat it returns\n\n\n\n\nsys.function()\nFunction object for current frame\n\n\nformals(f)\nList of arguments for function f\n\n\nbody(f)\nThe code block (body) of function f\n\n\nenvironment(f)\nThe enclosing environment where f was defined"
  },
  {
    "objectID": "posts/SysCall/index.html#real-scenario-logging-with-caller-info",
    "href": "posts/SysCall/index.html#real-scenario-logging-with-caller-info",
    "title": "Understanding R’s Call Stack: sys.call() and Friends",
    "section": "Real Scenario: Logging with Caller Info",
    "text": "Real Scenario: Logging with Caller Info\nCustom log_debug() with automatic caller identification:\n\nlog_debug &lt;- function(message) {\n  caller &lt;- as.character(sys.call(sys.parent()))[1]\n  cat(sprintf(\"[DEBUG] [%s] %s\\n\", caller, message))\n}\n\nprocess_data &lt;- function(x) {\n  log_debug(\"Starting data processing\")\n  # ... do something ... with `x`\n  y &lt;- x * 2\n  print(y)\n  log_debug(\"Finished processing\")\n}\n\nprocess_data(42)\n\n[DEBUG] [process_data] Starting data processing\n[1] 84\n[DEBUG] [process_data] Finished processing"
  },
  {
    "objectID": "posts/SysCall/index.html#quick-reference",
    "href": "posts/SysCall/index.html#quick-reference",
    "title": "Understanding R’s Call Stack: sys.call() and Friends",
    "section": "Quick Reference",
    "text": "Quick Reference\n\n\n\nFunction\nDescription\n\n\n\n\nsys.call()\nReturns the call to the current function\n\n\nsys.call(n)\nReturns the call from frame n\n\n\nsys.parent()\nReturns the index of the parent frame\n\n\nsys.frame()\nReturns the environment of a given frame\n\n\nsys.function()\nReturns the function evaluated in a given frame\n\n\nparent.frame()\nShortcut for the parent environment"
  },
  {
    "objectID": "posts/nse1/index.html",
    "href": "posts/nse1/index.html",
    "title": "What Is Non-Standard Evaluation (NSE) and Why Does It Matter?",
    "section": "",
    "text": "Non-Standard Evaluation (NSE) is one of the most powerful — and most confusing — features of the R language. It allows functions to manipulate the expressions that users write, instead of just their evaluated values. This behavior is at the heart of many modeling and data manipulation tools in R, including with(), subset(), and all of the tidyverse.\n\n\nBefore packages like dplyr, base R already offered functions that evaluated expressions in a different context — usually within a data frame — without requiring users to quote variable names.\nHere are two classic examples:\n\nwith(mtcars, mpg + cyl)\n\n [1] 27.0 27.0 26.8 27.4 26.7 24.1 22.3 28.4 26.8 25.2 23.8 24.4 25.3 23.2 18.4\n[16] 18.4 22.7 36.4 34.4 37.9 25.5 23.5 23.2 21.3 27.2 31.3 30.0 34.4 23.8 25.7\n[31] 23.0 25.4\n\n#&gt; Adds mpg and cyl from mtcars — no $ needed\n\nsubset(mtcars, mpg &gt; 20)\n\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n#&gt; Filters rows where mpg &gt; 20 — again, mpg is unquoted\n\nIn both cases, you are allowed to write expressions like mpg + cyl or mpg &gt; 20 directly, without using mtcars$mpg. This works because with() and subset() don’t evaluate their arguments immediately. Instead, they capture the expression you wrote and evaluate it inside the data frame environment.\nThis ability to manipulate expressions and control where they are evaluated is exactly what Non-Standard Evaluation enables.\n\n\n\nTo appreciate what NSE changes, it helps to understand what R does by default — which is standard evaluation (SE).\nIn SE, R evaluates every name and expression before passing it to a function. For example:\n\nx &lt;- 10\nf &lt;- function(y) y + 1\nf(x)\n\n[1] 11\n\n\nHere, x is evaluated to 10, and f() receives that value.\n\n\n\nWith NSE, a function can capture what the user typed — the unevaluated expression — and decide:\n\nWhen to evaluate it,\nWhere to evaluate it,\nOr even whether to evaluate it at all.\n\nLet’s create a minimal example:\n\nprint_expr &lt;- function(expr) {\n  print(expr)\n}\nprint_expr(x + 1)\n\n[1] 11\n\n\nLooks standard, right? Now try this:\n\nprint_expr &lt;- function(expr) {\n  print(substitute(expr))\n}\nprint_expr(x + 1)\n\nx + 1\n\n\nNow we’re seeing the expression x + 1 itself, rather than the result 11. That’s NSE in action: we intercepted the unevaluated code.\n\n\n\nLet’s write a simple logger that prints the code you typed:\n\nlog_eval &lt;- function(expr) {\n  cat(\"About to evaluate:\", deparse(substitute(expr)), \"\\n\")\n  result &lt;- eval(expr)\n  result\n}\n\nx &lt;- 2\nlog_eval(x + 3)\n\nAbout to evaluate: x + 3 \n\n\n[1] 5\n\n\nThis function:\n\nUses substitute() to capture the expression x + 3,\nPrints the expression,\nThen evaluates it.\n\nAs an aside, this can also be done using match.call(), which you can read more about using ?match.call(). Note the way the match.call() is subsetted – what does that tell you about the output of the function?\n\nlog_eval &lt;- function(expr) {\n  p &lt;- match.call()\n  cat(\"calling function:\", deparse(p[[1]]), \"\\n\")\n  cat(\"About to evaluate:\", deparse(p[[2]]), \"\\n\")\n  result &lt;- eval(expr)\n  result\n}\nlog_eval(x + 3)\n\ncalling function: log_eval \nAbout to evaluate: x + 3 \n\n\n[1] 5\n\nlog_eval(mean(x + c(5:10)))\n\ncalling function: log_eval \nAbout to evaluate: mean(x + c(5:10)) \n\n\n[1] 9.5"
  },
  {
    "objectID": "posts/nse1/index.html#intro",
    "href": "posts/nse1/index.html#intro",
    "title": "What Is Non-Standard Evaluation (NSE) and Why Does It Matter?",
    "section": "",
    "text": "Non-Standard Evaluation (NSE) is one of the most powerful — and most confusing — features of the R language. It allows functions to manipulate the expressions that users write, instead of just their evaluated values. This behavior is at the heart of many modeling and data manipulation tools in R, including with(), subset(), and all of the tidyverse.\n\n\nBefore packages like dplyr, base R already offered functions that evaluated expressions in a different context — usually within a data frame — without requiring users to quote variable names.\nHere are two classic examples:\n\nwith(mtcars, mpg + cyl)\n\n [1] 27.0 27.0 26.8 27.4 26.7 24.1 22.3 28.4 26.8 25.2 23.8 24.4 25.3 23.2 18.4\n[16] 18.4 22.7 36.4 34.4 37.9 25.5 23.5 23.2 21.3 27.2 31.3 30.0 34.4 23.8 25.7\n[31] 23.0 25.4\n\n#&gt; Adds mpg and cyl from mtcars — no $ needed\n\nsubset(mtcars, mpg &gt; 20)\n\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n#&gt; Filters rows where mpg &gt; 20 — again, mpg is unquoted\n\nIn both cases, you are allowed to write expressions like mpg + cyl or mpg &gt; 20 directly, without using mtcars$mpg. This works because with() and subset() don’t evaluate their arguments immediately. Instead, they capture the expression you wrote and evaluate it inside the data frame environment.\nThis ability to manipulate expressions and control where they are evaluated is exactly what Non-Standard Evaluation enables.\n\n\n\nTo appreciate what NSE changes, it helps to understand what R does by default — which is standard evaluation (SE).\nIn SE, R evaluates every name and expression before passing it to a function. For example:\n\nx &lt;- 10\nf &lt;- function(y) y + 1\nf(x)\n\n[1] 11\n\n\nHere, x is evaluated to 10, and f() receives that value.\n\n\n\nWith NSE, a function can capture what the user typed — the unevaluated expression — and decide:\n\nWhen to evaluate it,\nWhere to evaluate it,\nOr even whether to evaluate it at all.\n\nLet’s create a minimal example:\n\nprint_expr &lt;- function(expr) {\n  print(expr)\n}\nprint_expr(x + 1)\n\n[1] 11\n\n\nLooks standard, right? Now try this:\n\nprint_expr &lt;- function(expr) {\n  print(substitute(expr))\n}\nprint_expr(x + 1)\n\nx + 1\n\n\nNow we’re seeing the expression x + 1 itself, rather than the result 11. That’s NSE in action: we intercepted the unevaluated code.\n\n\n\nLet’s write a simple logger that prints the code you typed:\n\nlog_eval &lt;- function(expr) {\n  cat(\"About to evaluate:\", deparse(substitute(expr)), \"\\n\")\n  result &lt;- eval(expr)\n  result\n}\n\nx &lt;- 2\nlog_eval(x + 3)\n\nAbout to evaluate: x + 3 \n\n\n[1] 5\n\n\nThis function:\n\nUses substitute() to capture the expression x + 3,\nPrints the expression,\nThen evaluates it.\n\nAs an aside, this can also be done using match.call(), which you can read more about using ?match.call(). Note the way the match.call() is subsetted – what does that tell you about the output of the function?\n\nlog_eval &lt;- function(expr) {\n  p &lt;- match.call()\n  cat(\"calling function:\", deparse(p[[1]]), \"\\n\")\n  cat(\"About to evaluate:\", deparse(p[[2]]), \"\\n\")\n  result &lt;- eval(expr)\n  result\n}\nlog_eval(x + 3)\n\ncalling function: log_eval \nAbout to evaluate: x + 3 \n\n\n[1] 5\n\nlog_eval(mean(x + c(5:10)))\n\ncalling function: log_eval \nAbout to evaluate: mean(x + c(5:10)) \n\n\n[1] 9.5"
  },
  {
    "objectID": "posts/nse1/index.html#expressions-are-not-strings-understanding-how-r-represents-code",
    "href": "posts/nse1/index.html#expressions-are-not-strings-understanding-how-r-represents-code",
    "title": "What Is Non-Standard Evaluation (NSE) and Why Does It Matter?",
    "section": "2. Expressions Are Not Strings: Understanding How R Represents Code",
    "text": "2. Expressions Are Not Strings: Understanding How R Represents Code\nTo understand that piece of code fully, we need to know tools like substitute(), deparse(), or eval(). Yet, there is something even more fundamental to understand first:\n\nIn R, code is data.\n\nWhen you write x + 1, R does not treat that as text or as a string. Instead, it creates a structured object — an expression — that the interpreter can inspect, manipulate, or evaluate later.\nThis idea is essential to understanding how Non-Standard Evaluation (NSE) works.\n\nWhat Is an Expression?\nIn R, an expression is an object that represents unevaluated code.\nHere’s how you create one:\n\nexpr &lt;- quote(x + 1)\nexpr\n\nx + 1\n\n\nThis object is not the result of x + 1, and it’s not the character string \"x + 1\" (notice that it does not have quotes in the console). It’s a special object of class \"call\" — sometimes also called a language object.\nYou can verify this:\n\nclass(expr)\n\n[1] \"call\"\n\ntypeof(expr)\n\n[1] \"language\"\n\n\nThis means that R has captured the code itself — as structured, evaluable (i.e., unevaluated) data.\n\n\nWhy Expressions Are Not Strings\nTry this:\n\nexpr &lt;- quote(x + 1)\nis.character(expr)\n\n[1] FALSE\n\nprint(expr)\n\nx + 1\n\n\nEven though it looks like a string when printed, it’s not. R stores the structure of the code, not its textual representation.\nIn fact, expressions behave like recursive lists. You can inspect their components:\n\nexpr[[1]]  # the function being called\n\n`+`\n\nexpr[[2]]  # first argument\n\nx\n\nexpr[[3]]  # second argument\n\n[1] 1\n\n\nThis kind of structure is what makes metaprogramming possible in R.\n\n\nquote() – The Basic Tool to Capture Code\nquote() is the most direct way to create an expression.\n\nquote(mean(x, na.rm = TRUE))\n\nmean(x, na.rm = TRUE)\n\n\nThis returns a \"call\" object, which you can store, inspect, and evaluate later.\nquote() prevents R from evaluating the expression. It captures it as is, before any names are resolved.\nCompare:\n\nx &lt;- 10\n\n# This\nquote(x + 1)\n\nx + 1\n\n# To this\nx + 1\n\n[1] 11\n\n\nIn the first case, R captures the expression; in the second, it evaluates it.\nbquote() allows partial evaluation inside a quoted expression, useful for plotting or math expressions.\n\ne &lt;- rlang::env(x = 100, y = 300)\ny &lt;-  1\nquote(.(x) + y)\n\n.(x) + y\n\nbquote(.(x) + y) \n\n10 + y\n\n# part in .() is evaluated in `where` \nbquote(.(x) + y, where = e) \n\n100 + y\n\nbquote((x) + y)\n\n(x) + y\n\n\n\n\ndeparse() – Turning Code into Strings\nNow suppose you want to print this expression. If you use print(expr), you get a nice display. But if you need the actual string \"x + 1\" (e.g. for logging or including it in cat() or paste()), you need deparse():\n\nexpr &lt;- quote(x + 1)\ndeparse(expr)\n\n[1] \"x + 1\"\n\n\nSo:\n\nquote(x + 1) → structured expression\ndeparse(quote(x + 1)) → character string \"x + 1\"\n\nThis distinction is critical. If you treat expressions like strings too early, you lose their structure.\n\n\nsubstitute() – Capturing Expressions from Arguments\nWhile quote() is explicit, substitute() works implicitly by intercepting what the user typed as an argument.\nExample:\n\nlog_expr &lt;- function(arg) {\n  code &lt;- substitute(arg)\n  print(code)\n}\n\nlog_expr(x + 1)\n\nx + 1\n\n\nBehind the scenes, substitute(arg) is doing the same thing as quote(x + 1) — except it’s happening within the calling context. That’s why we often say that substitute() is a dynamic version of quote() — it’s context-sensitive.\nTo show the equivalence:\n\nquote(x + 1) == substitute(x + 1)\n\n[1] TRUE\n\n\nBut substitute(arg) only works inside a function — because it inspects the actual expression passed to arg.\n\n\nSo, what’s the difference between quote() and substitute()?\nBoth quote() and substitute() capture unevaluated code, but context matters.\n\nquote() always returns the literal symbol or expression, without considering the call context.\nsubstitute() captures what the user typed, dynamically, at the function call site.\n\n\nExample: Compare Their Behavior Inside a Function\n\ninspect &lt;- function(expr) {\n  list(\n    quoted      = quote(expr),         # Always returns the symbol 'expr'\n    substituted = substitute(expr),    # Captures the user's input expression\n    evaluated   = eval(expr)           # Executes the expression\n  )\n}\n\nx &lt;- 3\ninspect(x + 1)\n\n$quoted\nexpr\n\n$substituted\nx + 1\n\n$evaluated\n[1] 4\n\n\n\n\nKey Point:\n\nquote(expr) always gives you expr — the literal name.\nsubstitute(expr) gives you x + 1 — what the user typed.\neval(expr) computes the result.\n\nUse substitute() when writing functions that need to inspect or log user input. Use quote() when you need to manually build expressions.\n\n\n\nPutting It All Together\nLet’s summarize the roles:\n\n\n\n\n\n\n\n\nFunction\nPurpose\nReturns\n\n\n\n\nquote(expr)\nCapture unevaluated code\nExpression / call\n\n\nsubstitute(arg)\nCapture the argument passed to a function\nExpression / call\n\n\ndeparse(expr)\nConvert an expression to a string\nCharacter string\n\n\neval(expr)\nEvaluate the expression\nResult of computation"
  },
  {
    "objectID": "posts/nse1/index.html#combining-substitute-deparse-and-eval-in-real-world-logging",
    "href": "posts/nse1/index.html#combining-substitute-deparse-and-eval-in-real-world-logging",
    "title": "What Is Non-Standard Evaluation (NSE) and Why Does It Matter?",
    "section": "3. Combining substitute(), deparse(), and eval() in Real-World Logging",
    "text": "3. Combining substitute(), deparse(), and eval() in Real-World Logging\nNow that we understand the difference between quote() and substitute(), and how eval() and deparse() work, let’s build a real-world example that demonstrates why all of this matters in practice.\nImagine you’re writing a logging wrapper to:\n\nReport what expression the user typed\nEvaluate it\nRecord the result (or the error)\n\n\nA Logging Evaluator\n\nlog_and_eval &lt;- function(expr) {\n  # Capture the expression (as typed)\n  code &lt;- substitute(expr)\n\n  # Turn the code into readable text\n  code_text &lt;- deparse(code)\n\n  # Evaluate the expression\n  result &lt;- tryCatch(\n    expr = {\n      x &lt;- eval(code)\n          # Print and return\n      cli::cli_inform(\"Successfully evaluated: {code_text}\")\n      cli::cli_inform(\"Result: {x}\")\n    },\n    error = function(e) {\n      cli::cli_alert_danger(\"Error while evaluating: {code_text}\n                     MSG: {e$message}\")\n      return(NULL)\n    }\n  )\n\n  \n  invisible(result)\n}\n\n\n\nTry It Out\n\nx &lt;- 10\nlog_and_eval(x + 1)\n\nSuccessfully evaluated: x + 1\nResult: 11\n\n\n\nlog_and_eval(log(\"hello\"))  # will fail\n\n✖ Error while evaluating: log(\"hello\")\nMSG: non-numeric argument to mathematical function\n\n\n\n\nWhat Happens If You Try to Use eval(expr) Without substitute()?\nYou might wonder: why do we assign code &lt;- substitute(expr) and then evaluate code? Why not just call eval(expr) directly?\nHere’s why:\n\nWhen expr is passed to the function log_and_eval(), R evaluates it immediately, unless we explicitly tell it not to.\nThe role of substitute(expr) is to capture the unevaluated expression that the user typed at the call site.\nIf you skip substitute(), then expr has already been evaluated by the time it enters the function — and you’ve lost the original code.\n\nCompare with definition:\n\nlog_eval_wrong &lt;- function(expr) {\n  # expr has already been evaluated here\n  cat(\"Trying to print the expr. We just get the result: \", \n      deparse(expr), \"\\n\")\n  expr \n}\n\nCalling log_eval_wrong(x + 1) can’t show us the expression:\n\nx &lt;- 10\nlog_eval_wrong(x + 1)\n\nTrying to print the expr. We just get the result:  11 \n\n\n[1] 11\n\n\nThat’s because by the time deparse(expr) runs, expr has already been evaluated to a number (11), not an expression.\nWe use substitute() to freeze user input and eval() to control exactly when and where it runs."
  },
  {
    "objectID": "posts/nse1/index.html#controlling-where-code-is-evaluated-with-evalexpr-envir",
    "href": "posts/nse1/index.html#controlling-where-code-is-evaluated-with-evalexpr-envir",
    "title": "What Is Non-Standard Evaluation (NSE) and Why Does It Matter?",
    "section": "4. Controlling Where Code Is Evaluated with eval(expr, envir)",
    "text": "4. Controlling Where Code Is Evaluated with eval(expr, envir)\nSo far, we’ve used eval(expr) to run expressions in the current environment. But a key feature of eval() is that it also lets you choose where the code is evaluated — and this is essential for many real-world use cases.\n\nChanging the Environment\nYou can use eval(expr, envir = ...) to evaluate the code in a different environment. This lets you build flexible tools like scoped evaluators, delayed execution, and data-aware functions.\n\n# Create a custom environment\ncustom_env &lt;- rlang::env(x = 100)\n\nexpr &lt;- quote(x + 1)\neval(expr, envir = custom_env)\n\n[1] 101\n\n\nEven though there’s a global x &lt;- 5, the expression is evaluated in custom_env, where x = 100.\n\n\nWhy This Is Powerful\nThis behavior is foundational for base R tools like with() and subset(), and for tidyverse functions like dplyr::filter():\n\neval(quote(mpg &gt; 25), envir = mtcars)\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[13] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n[25] FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n\n\nHere, mpg is treated as a column inside mtcars, not as a variable in the global environment. This is how dplyr::filter(mtcars, mpg &gt; 25) works internally.\n\n\nHow to Use It in Your Own Code\nTo really see the importance of substitute(), let’s consider a slightly more advanced case: evaluating code in a different environment.\nSuppose you want to evaluate an expression using variables defined in a custom environment, not the global one. Here’s how it works when done correctly:\n\nlog_and_eval_env &lt;- function(expr, env = parent.frame()) {\n  code &lt;- substitute(expr)\n  code_text &lt;- deparse(code)\n  \n  result &lt;- tryCatch(\n    expr = {\n      x &lt;- eval(code, envir = env)\n           # Print and return\n      cli::cli_inform(\"Evaluated in custom env: {code_text}\")\n      cli::cli_inform(\"Result: {x}\")\n    },\n    error = function(e) {\n      cli::cli_alert_danger(\"Error in {code_text}: {e$message}\")\n      return(NULL)\n    }\n  )\n  \n  \n  invisible(result)\n}\n\n\n# we create x in env e\ne &lt;- rlang::env(x = 100)\n\n# and also have `x` in global \nx &lt;- 10\n\n# Here the code is evaluated in env `e`\nlog_and_eval_env(x + 1, env = e)\n\nEvaluated in custom env: x + 1\nResult: 101\n\n# This is evaluated in global env\nlog_and_eval_env(x + 1)\n\nEvaluated in custom env: x + 1\nResult: 11\n\n# Notice that we could create `y` in `e`\nlog_and_eval_env(y &lt;- x + 1, env = e)\n\nEvaluated in custom env: y &lt;- x + 1\nResult: 101\n\ne$y\n\n[1] 101\n\n# And it was not create in Global because it was evaluated in `e`\ny # this gives you error. \n\n[1] 1\n\n# But here, it was created in `y`\nlog_and_eval_env(y &lt;- x + 1)\n\nEvaluated in custom env: y &lt;- x + 1\nResult: 11\n\ny\n\n[1] 11\n\n\nThis works because substitute() captured the unevaluated expression x + 1, and eval() was able to look up x in the env environment.\nBut what happens if we don’t use substitute()?\n\nlog_eval_env_wrong &lt;- function(expr, env = parent.frame()) {\n  # expr has already been evaluated here!\n  text &lt;- deparse(expr)  # will  fail\n  result &lt;- eval(expr, envir = env)\n  cli::cli_inform(\"Result: {result}\")\n  invisible(result)\n}\n\nNow try:\n\nx &lt;- 10\nlog_eval_env_wrong(x + 1, env = e)\n\nResult: 11\n\nrm(x)\nlog_eval_env_wrong(x + 1, env = e)\n\nError: object 'x' not found\n\n\nThis code first returns 11, then throws an error. This happens because when expr reaches eval() it is already too late because it has already been evaluated to in deparse(), so eval() simply returns 11. In the second case, where x is removed from the Global environment, expr is evaluated in deparse() and fails.\nThis is also evident in the following code.\nSince the expression is y &lt;- x + 1, and e is passed as the evaluation environment, the assignment takes place in e.\nIn R, eval(expr, envir = some_env) does make assignments into some_env if the expression is syntactically an assignment, like y &lt;- something.\nBut this fails for assigning into foo()’s environment\n\n# Why this does not work. \nfoo &lt;- \\() {\n  y &lt;- 3 + 2\n  goo &lt;- \\() {\n  \n    eval(z &lt;- y + 2, envir = parent.frame())\n  }\n  goo()\n  z   # Error: object 'z' not found\n}\nfoo()\n\nError in foo(): object 'z' not found\n\n\nThat’s why substitute() is essential in any function that wants to control when and where evaluation happens. Now, this is how it works:\n\n# Why this does not work. \nfoo &lt;- \\() {\n  y &lt;- 3 + 2\n  goo &lt;- \\() {\n  \n    expr &lt;- substitute(z &lt;- y + 2) # this makes it work\n    eval(expr, envir = parent.frame())\n  }\n  goo()\n  z \n}\nfoo()\n\n[1] 7\n\n\nHowever, as we will see in another post, the best way to do this is assign(\"z\", value, envir = target_env). This is the safest and most readable."
  },
  {
    "objectID": "posts/Excp_Hndl/index.html",
    "href": "posts/Excp_Hndl/index.html",
    "title": "Mastering tryCatch() in R: From Basics to Structured Logging",
    "section": "",
    "text": "Error handling is a fundamental part of writing reliable R code. Whether you’re reading dozens of files, running a loop over thousands of observations, or building a data pipeline, something is bound to go wrong. When it does, tryCatch() allows your code to fail gracefully—without crashing your entire process.\nIn this post, we’ll start from scratch to understand how tryCatch() works, and build up to a practical and structured approach to logging and recovering from specific types of failures. Our goal is not just to catch errors, but to catch them with context, and handle them in a controlled and traceable way.\n\nlibrary(data.table)"
  },
  {
    "objectID": "posts/Excp_Hndl/index.html#introduction",
    "href": "posts/Excp_Hndl/index.html#introduction",
    "title": "Mastering tryCatch() in R: From Basics to Structured Logging",
    "section": "",
    "text": "Error handling is a fundamental part of writing reliable R code. Whether you’re reading dozens of files, running a loop over thousands of observations, or building a data pipeline, something is bound to go wrong. When it does, tryCatch() allows your code to fail gracefully—without crashing your entire process.\nIn this post, we’ll start from scratch to understand how tryCatch() works, and build up to a practical and structured approach to logging and recovering from specific types of failures. Our goal is not just to catch errors, but to catch them with context, and handle them in a controlled and traceable way.\n\nlibrary(data.table)"
  },
  {
    "objectID": "posts/Excp_Hndl/index.html#a-first-look-at-trycatch",
    "href": "posts/Excp_Hndl/index.html#a-first-look-at-trycatch",
    "title": "Mastering tryCatch() in R: From Basics to Structured Logging",
    "section": "1. A First Look at tryCatch()",
    "text": "1. A First Look at tryCatch()\nLet’s begin with a minimal example that handles a simple error:\n\ntryCatch(\n  expr = {\n    stop(\"Something went wrong!\")\n  },\n  error = function(e) {\n    message(\"Caught an error: \", e$message)\n    return(NA)\n  }\n)\n\nCaught an error: Something went wrong!\n\n\n[1] NA\n\n\nThis code tries to run the expression stop(\"...\"), which throws an error. The error = block intercepts that error and prints a message, returning NA instead.\nSimilarly, we can catch warnings:\n\ntryCatch(\n  expr = {\n    warning(\"Something is off...\")\n    42\n  },\n  warning = function(w) {\n    message(\"Caught a warning: \", w$message)\n    return(-1)\n  }\n)\n\nCaught a warning: Something is off...\n\n\n[1] -1\n\n\nAnd we can also define a finally block that always runs, even if there’s no error or warning:\n\ntryCatch(\n  expr = {\n    10\n  },\n  finally = {\n    message(\"This always runs.\")\n  }\n)\n\nThis always runs.\n\n\n[1] 10\n\n\nThe core idea is this: tryCatch() lets you write error-handling logic in the same place your code runs, using specific condition types (like error, warning, or custom classes)."
  },
  {
    "objectID": "posts/Excp_Hndl/index.html#a-practical-example-with-recovery-logic",
    "href": "posts/Excp_Hndl/index.html#a-practical-example-with-recovery-logic",
    "title": "Mastering tryCatch() in R: From Basics to Structured Logging",
    "section": "2. A Practical Example with Recovery Logic",
    "text": "2. A Practical Example with Recovery Logic\nLet’s look at a more realistic scenario. Suppose you have a function that sometimes succeeds, sometimes warns, and sometimes fails, depending on the input.\n\n\n\n\n\n\nNote\n\n\n\nThis example is an adaptation of Jonathanscallahan’s blog Basic Error Handing in R with tryCatch()\n\n\n\nmy_divide &lt;- function(d, a) {\n  if (a == \"warning\") {\n    warning(\"my_divide warning message\")\n    return(\"Warning fallback result\")\n  } else if (a == \"error\") {\n    stop(\"my_divide error message\")\n  } else {\n    return(d / as.numeric(a))\n  }\n}\n\nNow let’s use tryCatch() to run this function and react to each case:\n\nrun_example &lt;- function(a) {\n  result &lt;- tryCatch({\n\n    b &lt;- 2\n    c &lt;- b^2\n    d &lt;- c + 2\n\n    if (a == \"suppress-warnings\") {\n      e &lt;- suppressWarnings(my_divide(d, a))\n    } else {\n      e &lt;- my_divide(d, a)\n    }\n\n    f &lt;- e + 100\n    f\n\n  }, warning = function(w) {\n    message(\"Caught warning: \", conditionMessage(w))\n    e &lt;- my_divide(d, 0.1)\n    f &lt;- e + 100\n    return(f)\n\n  }, error = function(e) {\n    message(\"Caught error: \", conditionMessage(e))\n    e &lt;- my_divide(d, 0.01)\n    f &lt;- e + 100\n    return(f)\n\n  }, finally = {\n    message(\"a = \", a, \"| b = \", b, \"| c = \", c, \"| d = \", d)\n  })\n\n  message(\"Final result: \", result)\n  return(result)\n}\n\nTry it with different arguments:\n\nrun_example(\"warning\")\n\nCaught warning: my_divide warning message\n\n\na = warning| b = 2| c = 4| d = 6\n\n\nFinal result: 160\n\n\n[1] 160\n\nrun_example(\"error\")\n\nCaught error: my_divide error message\n\n\na = error| b = 2| c = 4| d = 6\n\n\nFinal result: 700\n\n\n[1] 700\n\nrun_example(\"2\")\n\na = 2| b = 2| c = 4| d = 6\n\n\nFinal result: 103\n\n\n[1] 103\n\nrun_example(\"suppress-warnings\")\n\na = suppress-warnings| b = 2| c = 4| d = 6\n\n\nFinal result: NA\n\n\n[1] NA\n\n\nThis function shows several important ideas:\n\nYou can distinguish between warnings and errors.\nYou can recover differently depending on what went wrong.\nThe finally block executes even if an error occurred.\nValues returned from the handler become the return value of the entire tryCatch() block."
  },
  {
    "objectID": "posts/Excp_Hndl/index.html#custom-error-classes-and-structured-conditions",
    "href": "posts/Excp_Hndl/index.html#custom-error-classes-and-structured-conditions",
    "title": "Mastering tryCatch() in R: From Basics to Structured Logging",
    "section": "3. Custom Error Classes and Structured Conditions",
    "text": "3. Custom Error Classes and Structured Conditions\nCatching errors like \"something went wrong\" is helpful, but not very specific. In a large pipeline, we often want to know:\n\nWhat type of error occurred\nWhich function or step caused it\nWhat data triggered the failure\n\nThis is where custom error classes and structured metadata become useful.\nLet’s say we want to define a special kind of error for when we detect duplicated rows in a dataset:\n\ndt &lt;- data.table(\n  country = c(\"A\", \"A\", \"B\", \"C\", \"C\"),\n  year = c(2020, 2020, 2021, 2022, 2022),\n  value = c(10, 10, 20, 30, 30),\n  id = c(\"A2020\", \"A2020\", \"B2021\", \"C2022\", \"C2022\")\n)\n\nkeyVar &lt;- c(\"country\", \"year\")\n\nWe can use cli::cli_abort() or rlang::abort() to raise an error with a custom class (using the class argument) and additional metadata with customed names arguments (i.e., arguments with names that you choose):\n\ncheck_for_duplicates &lt;- function(dt, keyVar) {\n  # Protect against unexpected base errors like missing columns\n  tryCatch({\n    if (uniqueN(dt, by = keyVar) != nrow(dt)) {\n      dup_rows &lt;- dt[duplicated(dt, by = keyVar)]\n      n_rep &lt;- nrow(dup_rows)\n\n      cli::cli_abort(\n        message = \"Found {n_rep} duplicated row(s) in the dataset.\",\n        class = c(\"dup_pfw\", \"validation_error\"),\n        key = keyVar,\n        ids = unique(dup_rows$id)\n      )\n    }\n\n    return(dt)\n  }, error = function(e) {\n    # Bubble up unknown errors as-is to be caught by outer tryCatch\n    stop(e)\n  })\n}\n\nThis raises a custom error of class \"dup_pfw\", which we can later catch specifically inside tryCatch():\n\nresult &lt;- tryCatch(\n  expr = check_for_duplicates(dt, keyVar),\n  \n  dup_pfw = function(e) {\n    message(\"Caught a known duplication issue.\")\n    message(\"Key used: \", paste(e$key, collapse = \", \"))\n    message(\"Affected IDs: \", paste(unique(e$ids), collapse = \", \"))\n    return(NULL)  # or apply a fix and return cleaned data\n  },\n\n  error = function(e) {\n    message(\"Caught an unknown error: \", conditionMessage(e))\n    return(NULL)\n  }\n)\n\nCaught a known duplication issue.\n\n\nKey used: country, year\n\n\nAffected IDs: A2020, C2022\n\n\n\nWhy is this better?\n\nWe’re not just catching any error — we’re catching expected errors by class.\nWe can extract metadata (e$key, e$ids) to include in a log or a diagnostic message.\nIf the error is not of class \"dup_pfw\", it’s passed on to the more general error handler.\n\nThis sets us up for a robust logging system: when a known issue occurs, we log it with context; if it’s unknown, we escalate it or halt."
  },
  {
    "objectID": "posts/Excp_Hndl/index.html#building-a-lightweight-logging-system",
    "href": "posts/Excp_Hndl/index.html#building-a-lightweight-logging-system",
    "title": "Mastering tryCatch() in R: From Basics to Structured Logging",
    "section": "4. Building a Lightweight Logging System",
    "text": "4. Building a Lightweight Logging System\nWhen your code is running on hundreds of datasets or in a production pipeline, you don’t just want to know that something failed—you want a record of what failed, where, and why.\nLet’s create a simple logging function that writes errors to a file:\n\nadd_log &lt;- function(cnd, logfile) {\n  timestamp &lt;- format(Sys.time(), \"%Y-%m-%d %H:%M:%S\")\n\n  cat(\n    \"[\", timestamp, \"] \",\n    \"[\", class(cnd)[1], \"] \",\n    cnd$message,\n    if (!is.null(cnd$ids)) {\n      paste(\" | IDs:\", paste(cnd$ids, collapse = \", \"))\n    },\n    \"\\n\",\n    file = logfile,\n    append = TRUE, \n    sep = \"\"\n  )\n}\n\nThis function takes any condition object and appends a formatted line to a plain-text file. It includes:\n\nThe time of the error\nThe class of the error\nThe message\nOptionally, any custom metadata (like IDs or keys)\n\n\nNow let’s use it inside a tryCatch() block:\n\nlogfile &lt;- tempfile(fileext = \".txt\")\n\nhandle_duplicates &lt;- function(dt, keyVar, logfile) {\n  tryCatch(\n    expr = check_for_duplicates(dt, keyVar),\n\n    dup_pfw = function(e) {\n      add_log(e, logfile = logfile)  # log the known duplication error\n      dt_clean &lt;- unique(dt, by = keyVar)  # remove duplicates\n      return(dt_clean)\n    },\n\n    error = function(e) {\n      add_log(e, logfile = logfile)  # log unknown errors too\n      message(\"Unexpected error occurred. See log for details.\")\n      return(NULL)  # &lt;-- graceful exit without re-raising the error\n      # Or, if you need the function to fail, you could do this:\n      # stop(\"Unexpected error occurred. See log for details.\")\n    }\n  )\n}\n\n\nhandle_duplicates(dt, keyVar, logfile)\n\n   country  year value     id\n    &lt;char&gt; &lt;num&gt; &lt;num&gt; &lt;char&gt;\n1:       A  2020    10  A2020\n2:       B  2021    20  B2021\n3:       C  2022    30  C2022\n\nhandle_duplicates(dt, \"wrongVar\", logfile)\n\nUnexpected error occurred. See log for details.\n\n\nNULL\n\n\nThis version of handle_duplicates() does three things:\n\nTries to detect duplicate rows.\nIf duplicates are found, it logs the error and removes them.\nIf an unknown error occurs, it logs that too—and stops execution.\n\nThis pattern is clean, recoverable, and extensible. You can add new condition classes for things like missing values, invalid columns, or range checks, and respond to each one differently.\n\n\nReading and Summarizing the Log File\nAfter logging multiple errors during a data-cleaning process, you may want to quickly inspect what went wrong. Here’s how to read the log and get a summary of known vs. unknown errors.\nLet’s assume we’ve used add_log() (from the previous section) to write to a file called log.txt.\n\n# Preview the raw log\nreadLines(logfile)\n\n[1] \"[2025-04-10 11:29:27] [dup_pfw] Found 2 duplicated row(s) in the dataset. | IDs: A2020, C2022\"                      \n[2] \"[2025-04-10 11:29:27] [simpleError] argument specifying columns received non-existing column(s): cols[1]='wrongVar'\"\n\n\n\n\nCreate a helper to summarize logs by type\nWe can write a small function (summarize_log()) to parse the log and report how many known and unknown errors occurred:\n\n\nCode\nsummarize_log &lt;- function(logfile) {\n  if (!file.exists(logfile)) {\n    message(\"No log file found.\")\n    return(invisible(NULL))\n  }\n\n  lines &lt;- readLines(logfile)\n\n  known &lt;- grep(\"\\\\[dup_pfw\\\\]\", lines, value = TRUE)\n  unknown &lt;- grep(\"\\\\[(simpleError|error)\\\\]\", lines, value = TRUE)\n\n  cat(\"== Log Summary ==\\n\")\n  cat(\"Total entries:\", length(lines), \"\\n\")\n  cat(\"Known 'dup_pfw' errors:\", length(known), \"\\n\")\n  cat(\"Other (unknown) errors:\", length(unknown), \"\\n\")\n\n  if (length(known)) {\n    cat(\"\\nKnown issues:\\n\")\n    cat(paste(\"-\", known), sep = \"\\n\")\n  }\n\n  if (length(unknown)) {\n    cat(\"\\nUnknown issues:\\n\")\n    cat(paste(\"-\", unknown), sep = \"\\n\")\n  }\n}\n\n#Now call it like this:\nsummarize_log(logfile)\n\n\n== Log Summary ==\nTotal entries: 2 \nKnown 'dup_pfw' errors: 1 \nOther (unknown) errors: 1 \n\nKnown issues:\n- [2025-04-10 11:29:27] [dup_pfw] Found 2 duplicated row(s) in the dataset. | IDs: A2020, C2022\n\nUnknown issues:\n- [2025-04-10 11:29:27] [simpleError] argument specifying columns received non-existing column(s): cols[1]='wrongVar'\n\n\nThis small addition turns your log from a flat text dump into a searchable, inspectable tool — one that could be expanded later to generate HTML reports, markdown diagnostics, or summaries across datasets."
  },
  {
    "objectID": "posts/Excp_Hndl/index.html#robust-example-with-cleaning-logging-and-skip_err-logic",
    "href": "posts/Excp_Hndl/index.html#robust-example-with-cleaning-logging-and-skip_err-logic",
    "title": "Mastering tryCatch() in R: From Basics to Structured Logging",
    "section": "5. Robust example with cleaning , logging, and skip_err Logic",
    "text": "5. Robust example with cleaning , logging, and skip_err Logic\nNow that we know how to catch and log structured and unexpected errors, let’s implement a more flexible function with real-world behavior:\n\nIt logs known issues (dup_pfw class).\nIt can skip or stop depending on a skip_err flag.\nIt logs any unexpected error.\n\n\nFunction: clean_duplicates()\nPay careful attention to this function because it has many important details and applied concepts.\n\nclean_duplicates &lt;- function(dt, keyVar, logfile, skip_err = TRUE) {\n  tryCatch(\n    expr = {\n      if (uniqueN(dt, by = keyVar) != nrow(dt)) {\n        dup_rows &lt;- dt[duplicated(dt, by = keyVar)]\n        n_rep &lt;- nrow(dup_rows)\n\n        cli::cli_abort(\n          message = \"Found {n_rep} duplicated row{?s}.\",\n          class = c(\"dup_pfw\", \"validation_error\"),\n          key = keyVar,\n          ids = unique(dup_rows$id),\n          skip = skip_err\n        )\n      }\n\n      return(dt)\n    },\n\n    dup_pfw = function(e) {\n      add_log(e, logfile)\n\n      if (!isTRUE(e$skip)) {\n        stop(\"Duplicate data found and skip_err = FALSE. See log.\")\n      }\n\n      # else skip and return cleaned data\n      dt_clean &lt;- unique(dt, by = keyVar)\n      return(dt_clean)\n    },\n\n    error = function(e) {\n      add_log(e, logfile)\n      if (!skip_err) {\n        stop(\"Unknown error. Halting execution. See log.\")\n      } else {\n        message(\"Unknown error. Skipping due to skip_err = TRUE.\")\n        return(NULL)\n      }\n    }\n  )\n}\n\n\n\nExample Usage\nCreate a dataset with duplicates:\n\ndt &lt;- data.table::data.table(\n  country = c(\"A\", \"A\", \"B\"),\n  year = c(2020, 2020, 2021),\n  value = c(10, 10, 20),\n  id = c(\"A2020\", \"A2020\", \"B2021\")\n)\n\nkeyVar &lt;- c(\"country\", \"year\")\nlogfile &lt;- tempfile(fileext = \".txt\")\n\nRun it with the default skip_err = TRUE:\n\nresult &lt;- clean_duplicates(dt, keyVar, logfile)\n# THis is the data cleaned, but the dulplicates\n# should be reported in logfile\nresult\n\n   country  year value     id\n    &lt;char&gt; &lt;num&gt; &lt;num&gt; &lt;char&gt;\n1:       A  2020    10  A2020\n2:       B  2021    20  B2021\n\n\nThen test the behavior when skip_err = FALSE:\n\n# this will create a similar entry in the log as the one above\n# since it is executed in the same second, I am adding a second to show that they \n# are different\nSys.sleep(1)\nclean_duplicates(dt, keyVar, logfile, skip_err = FALSE)\n\nError in value[[3L]](cond): Unknown error. Halting execution. See log.\n\n\nTry again with a bad key:\n\nclean_duplicates(dt, \"bad_column\", logfile)\n\nUnknown error. Skipping due to skip_err = TRUE.\n\n\nNULL\n\n\n\n\nRead the log:\n\n# using helper from earlier to get a quick summary.\nsummarize_log(logfile)\n\n== Log Summary ==\nTotal entries: 4 \nKnown 'dup_pfw' errors: 2 \nOther (unknown) errors: 2 \n\nKnown issues:\n- [2025-04-10 11:29:27] [dup_pfw] Found 1 duplicated row. | IDs: A2020\n- [2025-04-10 11:29:28] [dup_pfw] Found 1 duplicated row. | IDs: A2020\n\nUnknown issues:\n- [2025-04-10 11:29:28] [simpleError] Duplicate data found and skip_err = FALSE. See log.\n- [2025-04-10 11:29:28] [simpleError] argument specifying columns received non-existing column(s): cols[1]='bad_column'\n\n# Or use  `readLines(logfile)`"
  },
  {
    "objectID": "posts/Excp_Hndl/index.html#summary",
    "href": "posts/Excp_Hndl/index.html#summary",
    "title": "Mastering tryCatch() in R: From Basics to Structured Logging",
    "section": "Summary",
    "text": "Summary\nIn this post, we learned how to use tryCatch() in R for robust error handling and logging in data workflows. The post began by introducing the basic structure and mechanics of tryCatch(), including how to catch warnings, errors, and use a finally block for cleanup.\nWe then explored a practical example of a function (my_divide) that behaves differently based on input, showing how tryCatch() can handle known problems and apply recovery logic.\nNext, we introduced the concept of custom error classes using cli::cli_abort(), allowing for structured, class-based error signaling. By assigning custom classes (e.g., \"dup_pfw\") and attaching metadata (e.g., keys and identifiers), we created a mechanism for precise error identification and downstream handling.\nBuilding on this, we developed a lightweight logging function (add_log()) that writes structured error information to a file. This allowed for the creation of reproducible logs that can be summarized and inspected, enabling transparency and traceability in pipeline failures.\nTo inspect the logs, we created a summarize_log() function that parses the log file and distinguishes between known errors (like duplicate rows) and unknown errors (e.g., column not found), providing an accessible summary of all logged issues.\nFinally, we consolidated these techniques into a general-purpose function (clean_duplicates) that checks for duplicates, logs failures, and decides whether to continue or stop based on a skip_err flag. This function demonstrated how to handle both expected and unexpected errors, clean the data if possible, and capture complete information in the log file.\nTogether, these components form a modular and extensible framework for structured error handling, recovery, and logging in R, especially suitable for automated and large-scale data processing tasks."
  },
  {
    "objectID": "posts/Check_args/index.html",
    "href": "posts/Check_args/index.html",
    "title": "How to Create Robust Argument Checking in R Functions",
    "section": "",
    "text": "When developing functions in R, it’s essential to ensure that inputs meet specific criteria. One common and effective practice is creating an auxiliary function dedicated exclusively to validating arguments passed to another function. This approach helps to maintain clean, readable, and robust code."
  },
  {
    "objectID": "posts/Check_args/index.html#why-create-a-separate-argument-checking-function",
    "href": "posts/Check_args/index.html#why-create-a-separate-argument-checking-function",
    "title": "How to Create Robust Argument Checking in R Functions",
    "section": "Why Create a Separate Argument Checking Function?",
    "text": "Why Create a Separate Argument Checking Function?\nSeparating argument checking from your primary function logic provides several benefits:\n\nCode readability: Separating validation logic keeps your main functions concise and easy to understand.\nReusability: Validation logic can often be reused across multiple functions.\nMaintainability: Updating validation rules in one place is simpler and reduces the risk of inconsistencies."
  },
  {
    "objectID": "posts/Check_args/index.html#how-it-works",
    "href": "posts/Check_args/index.html#how-it-works",
    "title": "How to Create Robust Argument Checking in R Functions",
    "section": "How It Works",
    "text": "How It Works\nHere’s a straightforward and effective way to implement argument checking using an auxiliary function."
  },
  {
    "objectID": "posts/Check_args/index.html#practical-example",
    "href": "posts/Check_args/index.html#practical-example",
    "title": "How to Create Robust Argument Checking in R Functions",
    "section": "Practical Example",
    "text": "Practical Example\nBelow is an example demonstrating how one function (goo()) can validate the arguments of another function (foo()):\n\nfoo &lt;- function(x, y = 2, z = \"a\", ...) {\n  # Capture explicitly defined arguments\n  args &lt;- as.list(environment())\n\n  # Capture additional arguments from ...\n  args &lt;- c(args, list(...))\n\n  # Pass args list to goo\n  goo(args)\n}\n\n# Argument checking function\ngoo &lt;- function(args) {\n  # Expand arguments directly into goo's environment\n  list2env(args, envir = environment())\n\n  # Perform validation\n  stopifnot(\n    is.numeric(x),\n    is.numeric(y),\n    is.character(z)\n  )\n\n  # Additional checks for extra arguments in ...\n  if (exists(\"w\")) {\n    stopifnot(is.logical(w))\n  }\n\n  cat(\"All checks passed!\\n\")\n}"
  },
  {
    "objectID": "posts/Check_args/index.html#how-does-this-work",
    "href": "posts/Check_args/index.html#how-does-this-work",
    "title": "How to Create Robust Argument Checking in R Functions",
    "section": "How Does This Work?",
    "text": "How Does This Work?\nLet’s break down the logic:\n\nCapture arguments: The primary function (foo()) captures explicitly defined arguments and the additional arguments passed via the ellipsis (...) into a list.\nPass arguments for checking: The argument list (args) is passed to the auxiliary checking function (goo()).\nExpand and validate arguments: Inside goo(), we expand this list of arguments into its own environment using list2env(). This allows direct reference by their original names.\nArgument checks: We perform validation checks using stopifnot() to ensure each argument meets our criteria."
  },
  {
    "objectID": "posts/Check_args/index.html#examples-of-usage",
    "href": "posts/Check_args/index.html#examples-of-usage",
    "title": "How to Create Robust Argument Checking in R Functions",
    "section": "Examples of Usage",
    "text": "Examples of Usage\nLet’s demonstrate with some examples:\n\n# Example: correct arguments\nfoo(x = 1, y = 3, z = \"test\") # passes validation\n\n# Example: extra argument 'w' correctly specified as logical\nfoo(x = 1, w = TRUE) # passes validation\n\n# Example: incorrect 'x' argument type\nfoo(x = \"wrong\") # triggers error, x is not numeric\n\nError in goo(args): is.numeric(x) is not TRUE\n\n# Example: incorrect additional argument 'w'\nfoo(x = 1, w = \"wrong\") # triggers error, w is not logical\n\nError in goo(args): is.logical(w) is not TRUE"
  },
  {
    "objectID": "posts/Check_args/index.html#benefits-and-best-practices",
    "href": "posts/Check_args/index.html#benefits-and-best-practices",
    "title": "How to Create Robust Argument Checking in R Functions",
    "section": "Benefits and Best Practices",
    "text": "Benefits and Best Practices\n\nAlways clearly define your argument types and validations.\nCentralize your argument checking logic for consistency.\nConsider reusing or extending your argument checking function (goo()) for similar functions.\n\nAdopting this pattern greatly enhances your R programming practice by ensuring robustness, clarity, and efficiency."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Cool content about the development of PIP packages"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to PIP-Bloggers",
    "section": "",
    "text": "Non-Standard Evaluation (NSE) for developers\n\n\n\n\n\n\nR\n\n\nNSE\n\n\nMetaprogramming\n\n\n\n\n\n\n\n\n\nMay 9, 2025\n\n\nR.Andres Castaneda\n\n\n\n\n\n\n\n\n\n\n\n\nWhat Is Non-Standard Evaluation (NSE) and Why Does It Matter?\n\n\n\n\n\n\nR\n\n\nNSE\n\n\nMetaprogramming\n\n\n\nLearn how to use R’s Non-Standard Evaluation tools — quote(), substitute(), deparse(), and eval() — to capture, inspect, and control code execution. This post breaks down these core functions with clear examples for logging, metaprogramming, and tidy evaluation.\n\n\n\n\n\nApr 30, 2025\n\n\nR.Andres Castaneda\n\n\n\n\n\n\n\n\n\n\n\n\nCatching Errors Inside lapply(): Nested tryCatch and Clean Error Reporting in R\n\n\n\n\n\n\nR\n\n\nError Handling\n\n\nFunctional Programming\n\n\n\nLearn how to trace, classify, and report nested errors inside functional pipelines using tryCatch(), rlang, and cli.\n\n\n\n\n\nApr 11, 2025\n\n\nR. Andres Castañeda\n\n\n\n\n\n\n\n\n\n\n\n\nUnderstanding R’s Call Stack: sys.call() and Friends\n\n\n\n\n\n\nR\n\n\nMetaprogramming\n\n\nDebugging\n\n\n\nUnderstanding call stack introspection in R\n\n\n\n\n\nApr 8, 2025\n\n\nR.Andres Castaneda\n\n\n\n\n\n\n\n\n\n\n\n\nHow to Create Robust Argument Checking in R Functions\n\n\n\n\n\n\nR programming\n\n\nBest practices\n\n\n\nCreate a function that checks the arguments of another function\n\n\n\n\n\nMar 25, 2025\n\n\nR.Andres Castaneda\n\n\n\n\n\n\n\n\n\n\n\n\nCollapse Cheat sheet\n\n\n\n\n\n\ncollapse\n\n\ndata.table\n\n\ndplyr\n\n\nefficiency\n\n\n\nSyntax translation from dplyr and data.tablen to collapse\n\n\n\n\n\nMar 13, 2025\n\n\nPIP Technical team\n\n\n\n\n\n\n\n\n\n\n\n\nMastering tryCatch() in R: From Basics to Structured Logging\n\n\n\n\n\n\nR\n\n\nError Handling\n\n\nRobust Code\n\n\n\nLearn how to use tryCatch() in R to handle errors and warnings, recover from failures, and build structured logging systems.\n\n\n\n\n\nFeb 13, 2025\n\n\nDiana C. Garcia\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/collapse_cheat_sheet/index.html",
    "href": "posts/collapse_cheat_sheet/index.html",
    "title": "Collapse Cheat sheet",
    "section": "",
    "text": "This post is inspired in the Atreba’s blog: A data.table and dplyr tour. The objective of this post is to complement Atreba’s one with the syntax of the {collapse} R package."
  },
  {
    "objectID": "posts/collapse_cheat_sheet/index.html#introduction",
    "href": "posts/collapse_cheat_sheet/index.html#introduction",
    "title": "Collapse Cheat sheet",
    "section": "",
    "text": "This post is inspired in the Atreba’s blog: A data.table and dplyr tour. The objective of this post is to complement Atreba’s one with the syntax of the {collapse} R package."
  },
  {
    "objectID": "posts/collapse_cheat_sheet/index.html#basic-understanding-of-the-three-packages",
    "href": "posts/collapse_cheat_sheet/index.html#basic-understanding-of-the-three-packages",
    "title": "Collapse Cheat sheet",
    "section": "Basic understanding of the three packages",
    "text": "Basic understanding of the three packages\n\ndplyr\nA grammar of data manipulation in R which provides a consistent set of verbs to help you solve the most common data manipulation challenges. It is part of the tidyverse universe. Click here for more information..\n\n\ndata.table\nA syntax to operate data manipulation operations, such as subset, group, update, join, etc. It reduces programming and compute time tremendously. Click here for more information.\n\n\ncollapse\nA large C/C++ based package for data transformation and statistical computing in R. It aims to facilitate complex data transformations, explorations and computing tasks in R, while making code fast, flexible, parsimonious and programmer friendly. Click here for more information."
  },
  {
    "objectID": "posts/collapse_cheat_sheet/index.html#load-libraries",
    "href": "posts/collapse_cheat_sheet/index.html#load-libraries",
    "title": "Collapse Cheat sheet",
    "section": "Load libraries",
    "text": "Load libraries\n\nlibrary(dplyr)\nlibrary(data.table)\nlibrary(collapse)\nlibrary(tidyverse)"
  },
  {
    "objectID": "posts/collapse_cheat_sheet/index.html#data",
    "href": "posts/collapse_cheat_sheet/index.html#data",
    "title": "Collapse Cheat sheet",
    "section": "Data",
    "text": "Data\n\nset.seed(42)\n\n# Number of rows\nn &lt;- 10000\n\n# # Generate fake data\n# df &lt;- data.frame(\n#   id1 = 1:n,  # Unique ID\n#   id2 = sample(1:500, n, replace = TRUE),  # Repeating ID\n#   dt = seq.Date(from = as.Date(\"2023-01-01\"), by = \"day\", length.out = n),  # Dates\n#   tm = format(seq.POSIXt(from = as.POSIXct(\"2023-01-01 00:00:00\"), \n#                          by = \"hour\", length.out = n), \"%H:%M:%S\"),  # Time\n#   ch = sample(c(\"A\", \"B\", \"C\", \"D\"), n, replace = TRUE),  # Character\n#   int = sample(1:100, n, replace = TRUE),  # Integer\n#   log = sample(c(TRUE, FALSE), n, replace = TRUE),  # Logical\n#   realf = runif(n, 1, 100),  # Real (float),\n#   reald = runif(n),  # Real ,\n#   fct = factor(sample(c(\"X\", \"Y\", \"Z\"), n, replace = TRUE))  # Factor\n# )\n\nset.seed(42)\n\n# Number of rows\nn &lt;- 10000\n\n# Generate fake data with some NAs\ndf &lt;- data.frame(\n  id1 = 1:n,  # Unique ID\n  id2 = sample(1:500, n, replace = TRUE),  # Repeating ID\n  dt = sample(c(seq.Date(from = as.Date(\"2023-01-01\"), by = \"day\", length.out = n), NA), n, replace = TRUE),  # Dates with NAs\n  tm = sample(c(format(seq.POSIXt(from = as.POSIXct(\"2023-01-01 00:00:00\"), \n                                  by = \"hour\", length.out = n), \"%H:%M:%S\"), NA), n, replace = TRUE),  # Time with NAs\n  ch = sample(c(\"A\", \"B\", \"C\", \"D\", NA), n, replace = TRUE, prob = c(0.24, 0.24, 0.24, 0.24, 0.04)),  # Character with some NAs\n  int = sample(c(1:100, NA), n, replace = TRUE),  # Integer with some NAs\n  log = sample(c(TRUE, FALSE, NA), n, replace = TRUE, prob = c(0.49, 0.49, 0.02)),  # Logical with some NAs\n  realf = sample(c(runif(n, 1, 100), NA), n, replace = TRUE),  # Real (float) with some NAs\n  reald = sample(c(runif(n), NA), n, replace = TRUE),  # Real with some NAs\n  fct = factor(sample(c(\"X\", \"Y\", \"Z\", NA), n, replace = TRUE, prob = c(0.32, 0.32, 0.32, 0.04)))  # Factor with some NAs\n)\n\n# Print summary to check distribution of NAs\nsummary(df)\n\n\n# Ensure uniqueness\ndf &lt;- unique(df, by = c(\"id1\", \"id2\"))\ndt &lt;- copy(setDT(df))\ntb &lt;- as_tibble(df)"
  },
  {
    "objectID": "posts/collapse_cheat_sheet/index.html#basic-use",
    "href": "posts/collapse_cheat_sheet/index.html#basic-use",
    "title": "Collapse Cheat sheet",
    "section": "Basic use",
    "text": "Basic use\n\nFiltering rows\n\nFilter rows using indices\n\ncollapsedata.tabledplyr\n\n\n\n# super efficient\ndf |&gt; \n  ss(2:5)\n\n# efficient\ndf |&gt; \n  fsubset(2:5)\n\n\n\n\ndt[2:5]\n\n\n\n\ntb |&gt; \n  slice(2:5)\n\n# or using index like any data.frame\ntb[2:5,]\n\n# you need to add the comma. Otherwise, you get a different result\ntb[2:5]\n\n\n\n\n\n\nDiscard rows using negative indices\n\ncollapsedata.tabledplyr\n\n\n\ndf |&gt; \n  ss(-c(2:5)) |&gt; \n  head(4)\n\ndf |&gt; \n  ss(-c(2:5)) |&gt; \n  head(4)\n\n\n\n\ndt[!2:5] |&gt; \n  head(4)\n\n\n\n\ntb |&gt; \n  slice(-(2:5)) |&gt; \n  head(4)\n\n\n\n\n\n\nFilter rows using conditions\n\ncollapsedata.tabledplyr\n\n\n\ndf |&gt; \n  fsubset(ch == \"A\" & id1 == 6)\n\ndf |&gt; \n  fsubset(ch == x & id1 == 6)\n\n# This works\ndf |&gt; \n  fsubset(ch == ch & id1 == 6)\n\n# This does not work\ndf |&gt; \n  fsubset(ch == fct & id1 == 6)\n\n# This through error\ndf |&gt; \n  fsubset(ch == get(fct) & id1 == 6) |&gt; \n  try()\n\n# This works\ndf |&gt; \n  fsubset(ch == get(\"fct\", envir = -2) & id1 == 6) \n\n# NOTE: is there a better way?\n\n\n\n\ndt[ch == \"A\" & id1 == 6]\n\ndt[ch == x & id1 == 6]\n\ndt[ch ==ch & id1 == 6]\n\n# this does not work\ndt[ch == fct & id1 == 6]\n\n\ndt[ch == eval(fct) & id1 == 6]\n\n# These work but they are  verbose\ndt[ch == get(\"fct\", envir = parent.frame()) & id1 == 6]\ndt[ch == get(\"fct\", envir = -2) & id1 == 6]\n\n\n\n\ntb |&gt; \n  filter(ch == \"A\" & id1 == 6)\n\ntb |&gt; \n  filter(ch == x & id1 == 6)\n\ntb |&gt; \n  filter(ch == ch & id1 == 6)\n\n# does not work\ntb |&gt; \n  filter(ch == fct & id1 == 6)\n\n# works really well\ntb |&gt; \n  filter(ch == !!fct & id1 == 6)\n\n\n\n\n\n\nFilter unique rows\n\ncollapsedata.tabledplyr\n\n\n\n# Remove duplicate rows\ndf |&gt;\n  funique()\n\n# Keeps only one row per unique value in id2\ndf |&gt;\n  funique(cols = \"int\") # selecting column by col name \ndf |&gt;\n  funique(cols = 6)     # selecting column by indices\ndf |&gt;\n  funique(cols = names(df) %in% \"int\") # with logical condition\n\n\n\n\n # Remove duplicate rows\ndt |&gt;\n  unique()\n\n# Keeps only one row per unique value in id2\ndt |&gt;\n  unique(by = \"id2\")  \n\n\n\n\n# Remove duplicate rows\ntb |&gt;\n  distinct()\n\n# Keeps only one row per unique id1\ntb |&gt; distinct(id1, .keep_all = TRUE) # keep all col\n\n\n\n\n\n\nDiscard rows with missing values\n\ncollapsedata.tabletidyverse\n\n\n\n# Discard rows with any NA value\ndf |&gt;\n  na_omit()\n\n# Discard rows with NA value for selected col\ndf |&gt;\n  na_omit(cols = \"ch\")\n\n# More flexible options:\n# Remove rows where more than 50% of values are missing\ndf |&gt;\n  na_omit(prop = 0.5)\n\n\n\n\n# Discard rows with any NA value\ndt |&gt;\n  na_omit()\n\n# Discard rows with NA value for selected col\ndt &lt;- dt[!is.na(ch)]\n\n\n\n\n# Discard rows with any NA value\ntb |&gt;\n  tidyr::drop_na()\n\n# Discard rows with NA value for selected col\ntb |&gt; \n  tidyr::drop_na(ch)\n\n\n\n\n\n\nOther filters: slice options\n\ncollapsedata.tabledplyr\n\n\n\ndf |&gt;\n  fslice(n = 3)                 # First 3 rows\ndf |&gt;\n  fslice(n   = 3, \n         how = \"last\")          # Last 3 rows\ndf |&gt;\n  fslice(n = 0.1)               # Fraction of rows: first 10% of rows\n\nfslice(n        = 3, \n       how      = \"min\", \n       order.by = int)          # 3 obs with lowest int\n\n# TODO: add fslicev()\n\n\n\n\n# Frist 3 rows\ndt[1:3, ]   # First 3 rows, all columns\n\n\n# Last 3 rows\ndt[(.N-2):.N]  # .N gives the total number of rows\n\n# Fraction of rows: first 10% of rows\ndt[1:(.N * 0.1)]\n\n\n# 3 obs with lowest int\ndt[order(int)][1:3]\n\n\n\n\n# First 3 rows\ntb |&gt;\n  slice_head(n = 3)\n\n# Last 3 rows\ntb |&gt;\n  slice_tail(n = 3)\n\n# Fraction of rows: first 10% of rows\ntb |&gt;\n  slice_head(prop = 0.1)\n\n# 3 obs with lowest int\ntb |&gt;\n  slice_min(order_by = int, \n            n        = 3) # all rows\n\ntb |&gt;\n slice_min(order_by = int, \n           n        = 3, \n           with_ties = FALSE) \n\n\n\n\n\n\n\nSort rows\n\nSort rows by column(s)\n\ncollapsedata.tabledplyr\n\n\n\ndf |&gt;\n  roworder(id1)  \n\ndf |&gt;\n  roworder(-id2)      # Sort by decreasing order of id2\n\ndf |&gt;\n  roworder(id1, -id2) # Sort by multiple cols \n\n\n\n\ndt[order(id2)]    # This makes a copy\n\nsetorder(dt, id2) # To modify by reference  \n\ndt[order(-id2)]   # Sort by decreasing order\n\ndt[order(id1, -id2)] # Sort by multiple cols \n\n\n\n\ntb |&gt;\n  arrange(id2)\n\ntb |&gt;\n  arrange(desc(id2)) # Sort by decreasing order\n\n# Sort by multiple cols \ndf |&gt;\n   arrange(id1, desc(id2))\n\n\n\n\n\n\n\nSelect columns\n\nSelect one or more columns\n\ncollapsedata.tabledplyr\n\n\n\n## Select one column   ####\n# _________________________ \n\n# by index\ndf |&gt;\n  fselect(2)\n\ndf |&gt;\n  slt(2) # shorthand for fselect\n\n# by name\n\ndf |&gt;\n  fselect(id2)  # returns a dataframe \n\n## Select multiple columns ####\n# _____________________________ \n\ndf |&gt;\n  fselect(id1, id2, fct)\n\ndf |&gt;\n  fselect(id1, ch:fct)\n\n\n\n\n## Select one column   ####\n# _________________________ \n\n# by index\ndt[[3]]  # returns a vector\ndt[, 3]  # returns a data.table\n\n# by name\ndt[, list(id2)] # returns a data.table\ndt[, .(id2)]    # returns a data.table (. is an alias for list)\ndt[, \"id2\"]     # returns a data.table\ndt[, id2]       # returns a vector\ndt[[\"id2\"]]     # returns a vector\n\n## Select multiple columns ####\n# _____________________________ \n\ndt[, .(id1, id2, int)]\ndt[, list(id1, id2, int)]\ndt[, id2:int] # select columns between id2 and int\n\n\n\n\n## Select one column   ####\n# _________________________ \n\ntb |&gt;\n  select(id2)               # returns a tibble\n\npull(tb, id2, name = ch)    # returns a (named) vector\ntb[, \"id2\"]                 # returns a tibble\ntb[[\"id2\"]]                 # returns a vector\n\n## Select multiple columns ####\n# _____________________________ \n\ndf |&gt;\n  select(id1, id2, ch)\ndf |&gt;\n  select(id1, ch:fct)\n\n\n\n\n\n\nExclude columns\n\ncollapsedata.tabledplyr\n\n\n\n# Exclude columns by column names \ndf |&gt;\n  fselect(-dt, -tm)\n\n# Using a character vector \ncols &lt;- c(\"dt\", \"tm\")\n\ndf |&gt;\n  fselect(-cols)  # does not work \n\nError in -cols: invalid argument to unary operator\n\ndf |&gt;\n  fselect(!cols) # does not work \n\nError in !cols: invalid argument type\n\n# what is a better way to do this?\n\n\n\n\n# Exclude columns by column names \ndt[, !c(\"dt\", \"tm\")]\n\n# Using a character vector \ncols &lt;- c(\"dt\", \"tm\")\n\ndt[, ..cols] \n# .. prefix means 'one-level up', as cols is outside the parent environment \n\ndt[, !..cols] # or dt[, -..cols]\n\n\n\n\n# Exclude columns by column names \ntb |&gt;\n  select( -dt, -tm)\n\n# Using a character vector \ncols &lt;- c(\"dt\", \"tm\")\n\ntb |&gt;\n  select(all_of(cols))\n\ntb |&gt;\n  select(-all_of(cols))\n\n\n\n\n\n\nOther selections - not sure it is relevant, to check\n\n\n\nMiscellaneous\n\nRead & write data\n\nWrite\n\ncollapsedata.tabledplyr\n\n\n\n# no specific functions for reading and writing data \n\n\n\n\nfwrite(dt, \n       \"DT.csv\")                # write to csv\n\n\nfwrite(dt, \n       \"DT.txt\", \n       sep = \"\\t\")              # write to a tab-delimited file\n\n\n\n\nreadr::write_csv(tb, \n                 \"tb.csv\")  # write to csv\n\nreadr::write_delim(tb, \n                   \"tb.txt\", \n                   delim = \"\\t\")  # write to a tab-delimited file\n\n\n\n\n\n\nRead\n\ncollapsedata.tabledplyr\n\n\n\n# no specific functions for reading and writing data \n\n\n\n\nfread(\"dt.csv\")   # read csv\n# fread(\"DT.csv\", verbose = TRUE) # full details\n\nfread(\"dt.txt\", sep = \"\\t\") # read tab-delimited file\n\n# Read and rbind several files\nrbindlist(\n  lapply(c(\"dt.csv\", \"dt.csv\"), \n         fread))\n\n\n\n\nreadr::read_csv(\"tb.csv\")  # read csv\n\nreadr::read_delim(\"tb.txt\", \n                  delim = \"\\t\")  # read tab-delimited file\n\n# Read and rbind several files\nc(\"tb.csv\",  \"tb.csv\") |&gt;\n  purrr::map_dfr(readr::read_csv)\n\n\n\n\n\n\n\nReshape data\n\ncollapsedata.tabledplyr\n\n\n\n# ---- Long to Wide ----\nwide_pivot &lt;- pivot(df, \n                    ids    = c(\"id1\", \"id2\", \"dt\"),  # Columns to keep\n                    values = \"int\",              # Column with values\n                    names  = \"ch\",   # Column whose values become new cols\n                    how    = \"wider\")               # Reshape to wide format\n\n# ---- Wide to Long ----\nlong_pivot &lt;- pivot(wide_pivot, \n                    ids    = c(\"id1\", \"id2\", \"dt\"),  \n                    values = NULL,  \n                    names  = list(\"ch\", \"int\"),  \n                    how    = \"longer\")     \n\n\n\n\n# ---- Long to Wide ----\nwide_dt &lt;- dcast(dt, \n                 id1 + id2 + dt ~ ch, \n                 value.var = \"int\")\n\n# ---- Wide to Long ----\nlong_dt &lt;- melt(wide_dt, \n                id.vars       = c(\"id1\", \"id2\", \"dt\"), \n                variable.name = \"ch\", \n                value.name    = \"int\")\n\n\n\n\n# ---- Long to Wide ----\ntb_wide &lt;- tb |&gt;\n  # rm NAs\n  filter(!is.na(ch)) |&gt;\n  pivot_wider(names_from  = ch, \n              values_from = int)\n\n# ---- Wide to Long ----\ntb_long &lt;- tb_wide |&gt;\n  pivot_longer(cols      = c(\"A\", \"D\", \"C\", \"B\"),\n               values_to = \"int\",\n               names_to  = \"ch\")\n\n\n\n\n\n\n\nSummarise data\n\nSummarise columns\n\ncollapsedata.tabledplyr\n\n\n\n# efficient\ndf |&gt;\n  fsummarise(sum_rf = fsum(realf),\n             sd_rd = fsd(reald))\n\n# shorthand\ndf |&gt;\n  smr(sum_rf = fsum(realf),\n      sd_rd = fsd(reald))\n\n\n\n\ndt[, sum(realf)] # returns a vector\n\ndt[, .(sum(realf))] # returns a data.table\n\ndt[, .(sum_rf = sum(realf), # returns a data.table with named columns\n       sd_rd = sd(reald))]\n\n\n\n\nsummarise(tb, sum(realf)) # returns a tibble\n\ntb |&gt; \n  summarise(sum_rf = sum(realf), # returns a tibble\n            sd_rd = sd(reald))\n\n\n\n\n\n\nHelper functions\n\ncollapsedata.tabledplyr\n\n\nThe package includes fsum,fprod, fmedian, fmode, fvar, fsd, fmin,fmax,fnth, ffirst, flast,fnobs, and fndistinct.\n\n\nThe package includes first, last and uniqueN.\n\n\nThe package includes first, last, n, nth, and n_distinct.\n\n\n\n\n\n\nManipulations of columns\n\ncollapsedata.tabledplyr\n\n\n\n # Add one oe several columns (can also use ftransform)\ndf &lt;- df |&gt;\n  fmutate(log_rf = log(realf)) \n\ndf &lt;- df |&gt;\n  fmutate(log_rd = log(reald),\n           sqrt_rd = sqrt(reald))\n\n# Create one column and eliminate others\nfcompute(df, log2_rf = log_rf*2) \n\n # remove columns\ndf &lt;- df |&gt;\n  fselect(-log_rf,-log_rd,-sqrt_rd)\n\n\n\n\n# Add one column\ndt[, log_rf := log(realf)] \n\n# Add several columns\ndt[, ':=' (log_rd = log(reald), \n           sqrt_rd = sqrt(reald))]\n\n# Create one column and eliminate others\ndt[, .(log2_rf = log_rf*2)] \n\n# remove columns\ndt[, c(\"log_rf\", \"log_rd\", \"sqrt_rd\") := NULL] \n\n\n\n\n# Add one or several column\ntb &lt;- tb |&gt; \n  mutate(log_rf = log(realf))\n\ntb &lt;- tb |&gt; \n  mutate(log_rd = log(reald), \n           sqrt_rd = sqrt(reald))\n\n# Create one column and eliminate others\ntransmute(tb, log2_rf = log_rf*2)\n\n# remove columns\ntb &lt;- tb |&gt; \n  select(-log_rf,-log_rd,-sqrt_rd)\n\n\n\n\n\n\nby\n\ncollapsedata.tabledplyr\n\n\n\ndf |&gt; \n  fgroup_by(ch)|&gt;\n  fsummarise(sumrf = fsum(realf)) # ordered and indexed results\n\n# Assigned column name\n\ndf |&gt; \n  fgroup_by(abc = tolower(ch))|&gt;\n  fsummarise(sumrf = fsum(realf))\n\n# Add a column with number of observations for each group\n\ndf |&gt;\n  fgroup_by(ch)|&gt;\n  fcount(add = TRUE)\n\n\n\n\ndt[, .(sumrf = sum(realf)), by = \"ch\"] # unordered results\n\n# Reordered and indented:\n\ndt[, keyby = ch,\n     .(sumrf = sum(realf))]\n\n# Assigning column name\n\ndt[, keyby = .(abc = tolower(ch)),\n     .(sumrf = sum(realf))]\n\n# Add a column with number of observations for each group\n\ndt[, n := .N, by = ch][]\ndt[, n := NULL] # remove for consistency\n\n\n\n\ntb |&gt; \n  group_by(ch)|&gt;\n  summarise(sumrf = sum(realf)) # ordered results\n\n# Assigned column name\n\ntb |&gt; \n  group_by(abc = tolower(ch))|&gt;\n  summarise(sumrf = sum(realf))\n\n# Add a column with number of observations for each group\n\ntb |&gt;\n  group_by(ch)|&gt;\n  add_tally()\n\n# or...\n\nadd_count(tb, ch)"
  },
  {
    "objectID": "posts/collapse_cheat_sheet/index.html#going-further",
    "href": "posts/collapse_cheat_sheet/index.html#going-further",
    "title": "Collapse Cheat sheet",
    "section": "Going further",
    "text": "Going further\n\nAdvanced columns manipulation\n\ncollapsedata.tabledplyr\n\n\n\n# Summarize columns\ndf |&gt;\n  fsummarise(across(c(\"realf\", \"reald\"),\n            fmean))\n\n# Summarize using a condition\ndf |&gt;\n  fsummarise(across(is.numeric, # different from dplyr due to across\n                   fmean))\n\n# Modify all the columns\ndf |&gt; \n  fmutate(across(NULL,rev))\n\n# Modify several columns\ndf |&gt; \n  fcomputev(vars = c(\"realf\", \"reald\"), # dropping the other columns\n                  sqrt)\n\ndf &lt;- df |&gt;\n  ftransformv(vars = c(\"realf\", \"reald\"), # keeping the other columns\n                sqrt)\n\ndf &lt;- df |&gt;\n  ftransformv(vars = c(\"realf\", \"reald\"), # reverting for consistency\n                FUN = function(x){ x^2 })\n\n# Modify columns using a condition \n\ndf |&gt;\n  fcomputev(is.numeric,\n           FUN = function(x){x - 1})\n\n\n\n\n# Summarize columns\ndt[, lapply(.SD, mean),\n   .SDcols = c(\"realf\", \"reald\")]\n\n# Summarize using a condition\ndt[, lapply(.SD, mean),\n     .SDcols = is.numeric]\n\n# Modify all the columns\ndt[, lapply(.SD, rev)]\n\n# Modify several columns\ndt[, lapply(.SD, sqrt), # dropping the other columns\n     .SDcols = realf:reald]\n\ncols &lt;- c(\"realf\", \"reald\")\n\ndt[, (cols) := lapply(.SD, sqrt), # keeping the other columns\n     .SDcols = cols]\n\ndt[, (cols) := lapply(.SD, \"^\", 2L), # reverting for consistency\n     .SDcols = cols]\n\n# Modify columns using a condition \ndt[, .SD - 1,\n     .SDcols = is.numeric] \n\nrm(cols)\n\n\n\n\n# Summarize columns\ntb |&gt;\n  summarise(across(c(\"realf\", \"reald\"),\n            mean))\n\n# Summarize using a condition\ntb |&gt;\n  summarise(across(where(is.numeric),\n                   mean))\n\n# Modify all the columns\ntb |&gt; \n  mutate(across(everything(),\n                rev))\n\n# Modify several columns\ntb |&gt;\n  transmute(across(c(\"realf\", \"reald\"), # dropping the other columns\n                  sqrt))\n\ntb &lt;- tb |&gt;\n  mutate(across(all_of(c(\"realf\", \"reald\")), # keeping the other columns\n                sqrt))\n\ntb &lt;- tb |&gt;\n  mutate(across(all_of(c(\"realf\", \"reald\")), # reverting for consistency\n                ~ \"^\"(.x, 2L)))\n\n# Modify columns using a condition \n\ntb |&gt;\n  transmute(across(where(is.numeric), \n                   ~ '-'(., 1L)))\n\n\n\n\n\n\nChain expressions\n\ncollapsedata.tabledplyr\n\n\n\ndf |&gt;\n  fgroup_by(ch)|&gt;\n  fsummarise(sumrf = fsum(realf))|&gt;\n  fsubset(sumrf &lt; 129000)\n\n\n\n\ndt[, by = ch,\n   .(sumrf = sum(realf))][\n     sumrf &lt; 129000\n   ]\n\n\n\n\ntb |&gt;\n  group_by(ch)|&gt;\n  summarise(sumrf = sum(realf))|&gt;\n  filter(sumrf &lt; 129000)\n\n\n\n\n\n\nIndexing and keys (not sure it applies)\n\n\nset modifications\n\ncollapsedata.tabledplyr\n\n\n\n# Replace values (recommendation to use set of data.table)\n\nset(df, i = 1L, j = 2L, value = 30L) \n\n# Reorder rows\n\ndf &lt;- roworder(df, id2, -id1)\n\ndf &lt;- roworder(df, id1) # reversal for consistency\n\n# Modify column names\n\ndf &lt;- frename(df, dt = date)\n\ndf &lt;- frename(df, date = dt) # reversal for consistency\n\n# reorder columns\n\ndf &lt;- colorder(df, id1, id2, ch)\n\n\n\n\n# Replace values\n\nset(dt, i = 1L, j = 2L, value = 30L)\n\n# Reorder rows\n\nsetorder(dt, id2, -id1)\n\nsetorder(dt, id1) # reversal for consistency\n\n# Modify column names\n\nsetnames(dt, old = \"dt\", new = \"date\")\n\nsetnames(dt, old = \"date\", new = \"dt\")  # reversal for consistency\n\n# reorder columns\n\nsetcolorder(dt, c(\"id1\",\"id2\",\"ch\"))\n\n\n\n\n# Replace values\n\ntb[1,2] &lt;- 30L\n\n# Reorder rows\n\ntb &lt;- arrange(tb, id2, desc(id1))\n\ntb &lt;- arrange(tb, id1) # reversal for consistency\n\n# Modify column names\n\ntb &lt;- rename(tb, date = dt)\n\ntb &lt;- rename(tb, dt = date) # reversal for consistency\n\n# reorder columns\n\ntb &lt;- relocate(tb, c(\"id1\", \"id2\", \"ch\"))\n\n\n\n\n\n\nAdvanced use of by (maybe)"
  },
  {
    "objectID": "posts/collapse_cheat_sheet/index.html#joinbind-data-sets",
    "href": "posts/collapse_cheat_sheet/index.html#joinbind-data-sets",
    "title": "Collapse Cheat sheet",
    "section": "Join/Bind data sets",
    "text": "Join/Bind data sets\n\nBind\n\ncollapsedata.tabledplyr\n\n\n\nx &lt;- data.table(1:3)\ny &lt;- data.table(4:6)\nz &lt;- data.table(7:9, 0L)\n\n# bind rows\n\nrowbind(x, y, fill = TRUE) # always fills\n\n# bind rows using a list\n\nrowbind(list(x, y), idcol = \"id\")\n\n# bind columns\n\nbase::cbind(x, y)\n\nadd_vars(x) &lt;- y # modifies x but keeps data structure and attributes\n\n\n\n\nx &lt;- data.table(1:3)\ny &lt;- data.table(4:6)\nz &lt;- data.table(7:9, 0L)\n\n# bind rows\n\nrbind(x, y, fill = TRUE)\n\n# bind rows using a list\n\nrbindlist(list(x, y), idcol = \"id\")\n\n# bind columns\n\nbase::cbind(x, y)\n\nx &lt;- base::cbind(x, y) # modifies x but column names are not changed\n\n\n\n\nx &lt;- data.table(1:3)\ny &lt;- data.table(4:6)\nz &lt;- data.table(7:9, 0L)\n\n# bind rows\n\nbind_rows(x, y) # always fills\n\n# bind rows using a list\n\nbind_rows(list(x, y), .id = \"id\")\n\n# bind columns\n\nbind_cols(x, y)\n\nx &lt;- bind_cols(x, y) # modifies x and replace names"
  },
  {
    "objectID": "posts/collapse_cheat_sheet/index.html#efficient-functions-maybe",
    "href": "posts/collapse_cheat_sheet/index.html#efficient-functions-maybe",
    "title": "Collapse Cheat sheet",
    "section": "Efficient functions (maybe)",
    "text": "Efficient functions (maybe)"
  },
  {
    "objectID": "posts/collapse_cheat_sheet/index.html#other-useful-functions-in-collapse",
    "href": "posts/collapse_cheat_sheet/index.html#other-useful-functions-in-collapse",
    "title": "Collapse Cheat sheet",
    "section": "Other useful functions in collapse",
    "text": "Other useful functions in collapse\n\n# quick summary (From STATA summarize and xtsummarize)\n\nqsu(df, cols = c(\"realf\"))"
  },
  {
    "objectID": "posts/nested_trycatch/index.html",
    "href": "posts/nested_trycatch/index.html",
    "title": "Catching Errors Inside lapply(): Nested tryCatch and Clean Error Reporting in R",
    "section": "",
    "text": "In our previous posts [link here], we learned how to use tryCatch(), so I highly recommend your master it first, before reading this one.\nFunctional programming in R often leads us to use lapply() or purrr::map() to process many elements safely. To make our code robust, we usually wrap our functions in tryCatch() to handle errors gracefully.\nBut what happens when the real problem is inside the function?\nImagine this:\n\nYou’re looping over a list of inputs with lapply().\nEach item calls foo(), a composite function that internally calls bar(), baz(), and goo().\nOne of those inner functions fails — but all you get is a generic error message from the top-level tryCatch().\n\nThere’s no trace of which inner function was responsible, or what the input was. Debugging becomes a guessing game.\nIn this post, we’ll explore a clean, modular solution using nested tryCatch() blocks, rlang::abort(), and cli alerts — building up step by step toward a robust and informative logging system."
  },
  {
    "objectID": "posts/nested_trycatch/index.html#introduction",
    "href": "posts/nested_trycatch/index.html#introduction",
    "title": "Catching Errors Inside lapply(): Nested tryCatch and Clean Error Reporting in R",
    "section": "",
    "text": "In our previous posts [link here], we learned how to use tryCatch(), so I highly recommend your master it first, before reading this one.\nFunctional programming in R often leads us to use lapply() or purrr::map() to process many elements safely. To make our code robust, we usually wrap our functions in tryCatch() to handle errors gracefully.\nBut what happens when the real problem is inside the function?\nImagine this:\n\nYou’re looping over a list of inputs with lapply().\nEach item calls foo(), a composite function that internally calls bar(), baz(), and goo().\nOne of those inner functions fails — but all you get is a generic error message from the top-level tryCatch().\n\nThere’s no trace of which inner function was responsible, or what the input was. Debugging becomes a guessing game.\nIn this post, we’ll explore a clean, modular solution using nested tryCatch() blocks, rlang::abort(), and cli alerts — building up step by step toward a robust and informative logging system."
  },
  {
    "objectID": "posts/nested_trycatch/index.html#the-naive-setup",
    "href": "posts/nested_trycatch/index.html#the-naive-setup",
    "title": "Catching Errors Inside lapply(): Nested tryCatch and Clean Error Reporting in R",
    "section": "1: The Naive Setup",
    "text": "1: The Naive Setup\nLet’s simulate a real situation: a list of inputs that we want to process using foo().\nHere’s a basic setup:\n\n# Three inner functions\nbar &lt;- function(x) x + 1\nbaz &lt;- function(x) stop(\"baz failed!\")\ngoo &lt;- function(x) x * 2\n\n# A composite function\nfoo &lt;- function(x) {\n  bar(x) + baz(x) + goo(x)\n}\n\n# List of inputs (this could be files, datasets, IDs, etc.)\ninputs &lt;- list(1, 2, 3)\n\n# Wrap each call to foo() in a top-level tryCatch()\nresults &lt;- lapply(inputs, function(x) {\n  tryCatch(\n    foo(x),\n    error = function(e) {\n      message(\"Something failed at top level\")\n      NULL\n    }\n  )\n})\n\nSomething failed at top level\nSomething failed at top level\nSomething failed at top level\n\n\nThat’s… not very helpful.\nWhat input failed? Which internal function failed? Was it recoverable?\nWe’ve successfully caught the error — but lost all the useful context."
  },
  {
    "objectID": "posts/nested_trycatch/index.html#so-whats-the-problem",
    "href": "posts/nested_trycatch/index.html#so-whats-the-problem",
    "title": "Catching Errors Inside lapply(): Nested tryCatch and Clean Error Reporting in R",
    "section": "2: So What’s the Problem?",
    "text": "2: So What’s the Problem?\nAt first glance, it seems like our setup is doing the right thing — we’re catching errors, avoiding crashes, and moving on. But the moment something fails inside foo(), we’re left with this:\nThat’s it. No details. No traceback. No way to know what went wrong — or where.\nLet’s visualize the problem more clearly by making foo() and its components a bit noisier:\n\nbar &lt;- \\(x) {\n  message(\"Running bar()\")\n  x + 1\n}\n\nbaz &lt;- \\(x) {\n  message(\"Running baz()\")\n  if (x == 2) stop(\"baz() failed. `x` can't be 2.\")\n  x * 2\n}\n\ngoo &lt;- \\(x) {\n  message(\"Running goo()\")\n  x ^ 2\n}\n\nfoo &lt;- \\(x) {\n  bar(x) + baz(x) + goo(x)\n}\n\ninputs &lt;- list(1, 2, 3)\n\nresults &lt;- lapply(inputs, \\(x) {\n  tryCatch(\n    foo(x),\n    error = \\(e) {\n      message(\"Something failed at top level\")\n      NULL\n    }\n  )\n})\n\nRunning bar()\n\n\nRunning baz()\n\n\nRunning goo()\n\n\nRunning bar()\n\n\nRunning baz()\n\n\nSomething failed at top level\n\n\nRunning bar()\n\n\nRunning baz()\n\n\nRunning goo()\n\n\n\nWhy is this a big deal?\nIf you’re processing 10,000 files, or iterating over hundreds of models, it’s not enough to know that something failed. You need to know:\n\nWhich step in your process broke\nWhich input caused it\nWhat exactly the error was\n\nThat’s the kind of information we’ll learn to capture in the next section — by going inside foo() and catching errors at the source.\nLet’s level up our error handling."
  },
  {
    "objectID": "posts/nested_trycatch/index.html#catching-errors-where-they-happen-inside-foo",
    "href": "posts/nested_trycatch/index.html#catching-errors-where-they-happen-inside-foo",
    "title": "Catching Errors Inside lapply(): Nested tryCatch and Clean Error Reporting in R",
    "section": "3: Catching Errors Where They Happen (Inside foo())",
    "text": "3: Catching Errors Where They Happen (Inside foo())\nTo improve our error reporting, we need to stop treating foo() as a black box. If we want to know which internal function failed, we need to add tryCatch() blocks around each one of them — and give each failure a clear label.\nLet’s start by rewriting foo() so it wraps each of its components:\n\nfoo &lt;- function(x) {\n  out1 &lt;- tryCatch(\n    bar(x),\n    error = function(e) {\n      stop(sprintf(\"Error in bar(): %s\", e$message), call. = FALSE)\n    }\n  )\n\n  out2 &lt;- tryCatch(\n    baz(x),\n    error = function(e) {\n      stop(sprintf(\"Error in baz(): %s\", e$message), call. = FALSE)\n    }\n  )\n\n  out3 &lt;- tryCatch(\n    goo(x),\n    error = function(e) {\n      stop(sprintf(\"Error in goo(): %s\", e$message), call. = FALSE)\n    }\n  )\n\n  out1 + out2 + out3\n}\n\nLet’s run the same loop again:\n\ninputs &lt;- list(1, 2, 3)\n\nresults &lt;- lapply(inputs, function(x) {\n  tryCatch(\n    foo(x),\n    error = function(e) {\n      message(\"Top-level handler:\")\n      message(\"  \", e$message)\n      NULL\n    }\n  )\n})\n\nRunning bar()\n\n\nRunning baz()\n\n\nRunning goo()\n\n\nRunning bar()\n\n\nRunning baz()\n\n\nTop-level handler:\n\n\n  Error in baz(): baz() failed. `x` can't be 2.\n\n\nRunning bar()\n\n\nRunning baz()\n\n\nRunning goo()\n\n\n\nNow we know exactly what happened:\n\nWhich function failed: baz()\nWhy it failed: \"baz() failed on input 2\"\nAnd from where: foo() passed it up\n\nThis is already a huge improvement — now each internal component is accountable.\n\n\nBut there’s still one thing missing…\nWe’re building custom messages, which is nice — but we’re still working with base R errors, which can be brittle when we want to attach structured metadata (like the value of x, or the specific step name).\nTo fix that, we’ll bring in {rlang}, which has a special approach to error handling that makes structured, classed errors easy to build and trace."
  },
  {
    "objectID": "posts/nested_trycatch/index.html#using-rlangabort-for-structured-traceable-errors",
    "href": "posts/nested_trycatch/index.html#using-rlangabort-for-structured-traceable-errors",
    "title": "Catching Errors Inside lapply(): Nested tryCatch and Clean Error Reporting in R",
    "section": "4: Using rlang::abort() for Structured, Traceable Errors",
    "text": "4: Using rlang::abort() for Structured, Traceable Errors\nSo far, we’ve wrapped internal calls with tryCatch() and labeled their failures manually using stop(). That works, but it’s not ideal for larger pipelines where we want to:\n\nAttach structured metadata to the error (like x, or which step failed)\nUse custom error classes to distinguish error types\nImprove traceability and logging across multiple layers\n\nThis is where {rlang} comes in.\n\nrlang::abort() — Your New Best Friend\nLet’s redefine our inner functions to use rlang::abort() with custom classes and metadata:\n\nbar &lt;- function(x) {\n  message(\"Running bar()\")\n  x + 1\n}\n\nbaz &lt;- function(x) {\n  message(\"Running baz()\")\n  if (x == 2) {\n    rlang::abort(\"baz() failed. `x` can't be 2\", \n          .subclass = \"baz_error\", \n          foo_step = \"baz\", \n          input_value = x)\n  }\n  x * 2\n}\n\ngoo &lt;- function(x) {\n  message(\"Running goo()\")\n  x ^ 2\n}\n\nWhat’s going on here?\n\n.subclass = \"baz_error\" creates a custom error class\nfoo_step = \"baz\" and input_value = x add metadata to the error object\n\nThese can be used later to filter, inspect, or respond differently to different error types or sources.\n\n\nUpdating foo() to propagate structured errors\nLet’s now let foo() act as a smart forwarder of the error — without rewriting the message manually:\n\nfoo &lt;- function(x) {\n  tryCatch(\n    {\n      out1 &lt;- bar(x)\n      out2 &lt;- baz(x)\n      out3 &lt;- goo(x)\n      out1 + out2 + out3\n    },\n    error = function(e) {\n      # Bubble up the error as-is\n      rlang::abort(\n        message = e$message,\n        .subclass = \"foo_error\",\n        parent = e,             # preserve the original error\n        input_value = x\n      )\n    }\n  )\n}\n\nNotice we’re using parent = e, which preserves the original error and its metadata in a nested structure. This allows the top-level handler to inspect both the foo_error and the baz_error that caused it.\n\n\nExample: Let’s test it with a top-level handler\n\nlog_failure &lt;- function(e) {\n  cli::cli_alert_danger(\"Something went wrong in {.strong foo()}\")\n  cli::cli_alert(\"Original error: {conditionMessage(e)}\")\n  \n  if (inherits(e, \"baz_error\")) {\n    cli::cli_alert(\"Failure originated in step {.strong {e$foo_step}} with input {.code {e$input_value}}\")\n  }\n  \n  NULL\n}\n\ninputs &lt;- list(1, 2, 3)\n\nresults &lt;- lapply(inputs, function(x) {\n  tryCatch(\n    foo(x),\n    error = log_failure\n  )\n})\n\nRunning bar()\n\n\nRunning baz()\n\n\nRunning goo()\n\n\nRunning bar()\n\n\nRunning baz()\n\n\n✖ Something went wrong in foo()\n\n\n→ Original error: baz() failed. `x` can't be 2 Caused by error in `baz()`: ! baz() failed. `x` can't be 2\n\n\nRunning bar()\n\n\nRunning baz()\n\n\nRunning goo()\n\n\nNow we have:\n\nStructured information preserved across the stack\nClear logs with exact failure step and input\nComposability — you can extend this to more steps, pipelines, or input types\n\nIn the next step, we’ll wrap this all up into a reusable pattern that’s clean, readable, and powerful — with the help of cli and maybe a custom safe_step() function."
  },
  {
    "objectID": "posts/nested_trycatch/index.html#building-a-safe_step-helper-to-simplify-nested-trycatch",
    "href": "posts/nested_trycatch/index.html#building-a-safe_step-helper-to-simplify-nested-trycatch",
    "title": "Catching Errors Inside lapply(): Nested tryCatch and Clean Error Reporting in R",
    "section": "5. Building a safe_step() Helper to Simplify Nested tryCatch()",
    "text": "5. Building a safe_step() Helper to Simplify Nested tryCatch()\nAs we’ve seen, when foo() calls several subfunctions like bar(), baz(), and goo(), each of which might fail, we often want to:\n\nCatch the error locally.\nIdentify which function failed.\nPropagate the failure back to foo() with context.\n\nBut repeating the same tryCatch() logic inside each subfunction leads to duplicated code and clunky structure. Instead, we can define a small helper called safe_step() that wraps any step with the appropriate error-catching logic.\n\nDefine safe_step()\n\nsafe_step &lt;- function(expr, step_name) {\n  tryCatch(\n    expr = eval(expr, envir = parent.frame()),  # This ensures that x will be found inside foo()'s environment when safe_step() evaluates bar(x), baz(x), and goo(x).\n    error = function(e) {\n      rlang::abort(\n        message = sprintf(\"Step '%s' failed: %s\", step_name, conditionMessage(e)),\n        class = \"pipeline_step_error\",\n        step = step_name,\n        parent = e\n      )\n    }\n  )\n}\n\nThis function takes two arguments:\n\nexpr: the expression to evaluate, passed as a quoted expression (we’ll use quote() or {} blocks).\nstep_name: a label used to identify the step in case of failure.\n\nIt evaluates the expression, and if there’s an error, it “rethrows” it with a message indicating which step failed. The re-thrown error can then be caught by a top-level tryCatch() for logging or summarizing. Also, we user the .call argumetn because we only want to show the message.\n\n\nRewrite foo() using safe_step()\n\nbar &lt;- function(x) x + 1\nbaz &lt;- function(x) stop(\"something broke in baz()\")\ngoo &lt;- function(x) x * 2\n\n\nfoo &lt;- function(x) {\n  result1 &lt;- safe_step(quote(bar(x)), \"bar()\")\n  result2 &lt;- safe_step(quote(baz(x)), \"baz()\")\n  result3 &lt;- safe_step(quote(goo(x)), \"goo()\")\n  return(\"all steps completed\")\n}\n\nNow each step is wrapped with failure context. You can call foo() inside a top-level tryCatch() that logs errors:\n\ntryCatch(\n  foo(10),\n  error = function(e) {\n    message(\"Top-level handler: \", conditionMessage(e))\n    message(\"Step: \", e$step)\n    if (!is.null(e$parent)) {\n      message(\"Root cause: \", conditionMessage(e$parent))\n    }\n  }\n)\n\nTop-level handler: Step 'baz()' failed: something broke in baz()\nCaused by error in `baz()`:\n! something broke in baz()\n\n\nStep: baz()\n\n\nRoot cause: something broke in baz()\n\n\nThis makes debugging and logging much easier, as the step name is already encoded in the error message — without requiring each subfunction to carry its own tryCatch() block.\n\n\n\n\n\n\nWhy we use quote() in safe_step()\n\n\n\nIn the foo() function, we pass expressions like bar(x) to safe_step() using quote():\nfoo &lt;- function(x) {\n  safe_step(quote(bar(x)), \"bar()\")\n  ...\n}\nThis is necessary because safe_step() is designed to evaluate the expression inside a tryCatch() block, so we must delay its evaluation. If we called bar(x) directly, it would be executed before being passed to safe_step() — which defeats the purpose of catching its errors.\nBy using quote(bar(x)), we pass the unevaluated expression to safe_step(), and then use eval(expr) within the tryCatch() block to safely run it."
  },
  {
    "objectID": "posts/nested_trycatch/index.html#logging-failures-across-many-inputs-in-a-pipeline",
    "href": "posts/nested_trycatch/index.html#logging-failures-across-many-inputs-in-a-pipeline",
    "title": "Catching Errors Inside lapply(): Nested tryCatch and Clean Error Reporting in R",
    "section": "6. Logging Failures Across Many Inputs in a Pipeline",
    "text": "6. Logging Failures Across Many Inputs in a Pipeline\nWhen running a pipeline or loop over many inputs it’s critical to:\n\nKeep the pipeline running even if some elements fail.\nLog which input failed and why.\nRetain detailed metadata to help with debugging later.\n\nWe’ll now simulate such a setup using lapply() and the advanced error-handling tools we’ve built.\n\n6.1: Define a failing function with metadata\nWe’ll simulate a function that may fail depending on the input:\n\nprocess_one &lt;- function(x) {\n  if (x %% 2 == 0) {\n    rlang::abort(\n      message = \"Even numbers are not allowed\",\n      class = \"even_input_error\",\n      input_value = x,\n      step = \"process_one()\"\n    )\n  }\n  return(x^2)\n}\n\n# Good call\nprocess_one(3)\n\n[1] 9\n\n# Bad call\nprocess_one(4)\n\nError in `process_one()`:\n! Even numbers are not allowed\n\n\n\n\n6.2: Wrap the processing logic and re-throw\nHere’s a higher-level wrapper that runs one input and rethrows any error with parent = to retain the original condition:\n\nrun_with_context &lt;- function(x) {\n  tryCatch(\n    {\n      result &lt;- process_one(x)\n      return(result)\n    },\n    error = function(e) {\n      rlang::abort(\n        message = \"Pipeline step failed\",\n        .subclass = \"pipeline_error\",\n        input_id = x,\n        parent = e\n      )\n    }\n  )\n}\n\n# Good call\nrun_with_context(3)\n\n[1] 9\n\n# Bad call\nrun_with_context(4)\n\nError in `run_with_context()`:\n! Pipeline step failed\nCaused by error in `process_one()`:\n! Even numbers are not allowed\n\n\nNotice that it still throws an error, but it propagates the erors upward and it adds context and metadata to errors in a consistent, predictable way.\n\n\n6.3: Logging function using find_condition()\nWe’ll define a logger that extracts metadata from the deepest cause in the chain:\n\nfind_condition &lt;- function(cnd, class) {\n  while (!is.null(cnd)) {\n    if (inherits(cnd, class)) return(cnd)\n    cnd &lt;- cnd$parent\n  }\n  NULL\n}\n\nlog_failure &lt;- function(e, logfile) {\n  ts &lt;- format(Sys.time(), \"%Y-%m-%d %H:%M:%S\")\n\n  root &lt;- find_condition(e, \"even_input_error\")\n\n  line &lt;- if (!is.null(root)) {\n    sprintf(\"[%s] [even_input_error] input = %s | %s\", ts, root$input_value, conditionMessage(root))\n  } else {\n    sprintf(\"[%s] [unknown_error] %s\", ts, conditionMessage(e))\n  }\n\n  cat(line, \"\\n\", file = logfile, append = TRUE)\n  return(NULL)  # so lapply returns NULL on failure\n}\n\n\n\n6.4: Run lapply() over many inputs\n\ninputs &lt;- 1:6\nlogfile &lt;- tempfile(fileext = \".log\")\n\nresults &lt;- lapply(inputs, function(x) {\n  tryCatch(\n    run_with_context(x),\n    error = function(e) log_failure(e, logfile)\n  )\n})\n\n\n\n6.5: Review the log\n\nreadLines(logfile)\n\n[1] \"[2025-04-10 14:39:35] [even_input_error] input = 2 | Even numbers are not allowed \"\n[2] \"[2025-04-10 14:39:35] [even_input_error] input = 4 | Even numbers are not allowed \"\n[3] \"[2025-04-10 14:39:35] [even_input_error] input = 6 | Even numbers are not allowed \"\n\n\n\n\nFinal Notes\n\nThis pattern keeps lapply() running, logs structured details, and tracks failures by input.\nThe error messages remain informative thanks to metadata and error chaining.\nYou can extend this by saving successful results, failed cases, and summaries into structured reports."
  },
  {
    "objectID": "posts/nse2/index.html",
    "href": "posts/nse2/index.html",
    "title": "Non-Standard Evaluation (NSE) for developers",
    "section": "",
    "text": "Non-Standard Evaluation (NSE) is not just a curiosity — it’s a core part of modern R programming, especially for package developers who want to:\n\nBuild clean, expressive interfaces (like dplyr::filter(mpg &gt; 20))\nDelay or relocate expression evaluation\nWrite tools for logging, debugging, or metaprogramming\n\nTo use NSE effectively, you need more than quote() or substitute(). You need tools that work inside functions, play well with environments, and support user-friendly interfaces. That’s where base tools like get() and modern tools from {rlang} come in."
  },
  {
    "objectID": "posts/nse2/index.html#why-nse-matters-for-developers",
    "href": "posts/nse2/index.html#why-nse-matters-for-developers",
    "title": "Non-Standard Evaluation (NSE) for developers",
    "section": "",
    "text": "Non-Standard Evaluation (NSE) is not just a curiosity — it’s a core part of modern R programming, especially for package developers who want to:\n\nBuild clean, expressive interfaces (like dplyr::filter(mpg &gt; 20))\nDelay or relocate expression evaluation\nWrite tools for logging, debugging, or metaprogramming\n\nTo use NSE effectively, you need more than quote() or substitute(). You need tools that work inside functions, play well with environments, and support user-friendly interfaces. That’s where base tools like get() and modern tools from {rlang} come in."
  },
  {
    "objectID": "posts/nse2/index.html#retrieving-variables-from-custom-environments",
    "href": "posts/nse2/index.html#retrieving-variables-from-custom-environments",
    "title": "Non-Standard Evaluation (NSE) for developers",
    "section": "2. Retrieving Variables from Custom Environments",
    "text": "2. Retrieving Variables from Custom Environments\nLet’s start with something simple — but deceptive: using get() to evaluate code in a different environment.\n\n2.1 The Basic Idea of get()\nget() is a base R function that retrieves the value bound to a name from an environment. It’s equivalent to doing env$name, but with more flexibility:\n\nenv &lt;- rlang::env(x = 100)\nget(\"x\", envir = env)\n\n[1] 100\n\n\nThis looks simple. But it only works if you already know the name as a string.\nIf you try:\n\nvar &lt;- quote(x + 1)\nget(var, envir = env)\n\nError in get(var, envir = env): invalid first argument\n\n\nYou’ll get an error: get() doesn’t evaluate expressions — just single symbols (variable names). This limitation is why get() is only useful in very narrow NSE contexts.\n\n\n2.2 Why get() Is Not Enough\nSuppose you write a generic logging function like this:\n\nlog_get &lt;- function(var_name, env = parent.frame()) {\n  value &lt;- get(var_name, envir = env)\n  cat(\"Found\", var_name, \"with value:\", value, \"\\n\")\n}\n\nIt works:\n\nx &lt;- 42\nlog_get(\"x\")\n\nFound x with value: 42 \n\n\nBut now try:\n\nlog_get(\"x + 1\")\n\nError in get(var_name, envir = env): object 'x + 1' not found\n\n\nThis fails — because \"x + 1\" is not a symbol. It’s a string that represents an expression, and get() can’t parse or evaluate it.\n\n\n2.3 Using eval() Instead of get()\nTo evaluate expressions, we need eval():\n\nenv &lt;- rlang::env(x = 100)\nexpr &lt;- quote(x + 1)\neval(expr, envir = env)\n\n[1] 101\n\n\nThis works because eval() knows how to process structured expressions (not just names) and can recursively resolve variables.\nNow wrap this in a function:\n\nlog_eval_expr &lt;- function(expr, env = parent.frame()) {\n  val &lt;- eval(expr, envir = env)\n  cat(\"Expression\", deparse(expr), \"evaluated to\", val, \"\\n\")\n}\n\nx &lt;- 5\nlog_eval_expr(quote(x + 1))\n\nExpression x + 1 evaluated to 6 \n\n\nTakeaway: Use get() when you have a name, use eval() when you have a language object (i.e., an expression).\n\n\n2.4 What about substitute()\nYou may wonder why we are not using substitute in this function as we learned in the previous post? Good question. You need substitute() when you’re writing a function that receives user-typed code (unevaluated), and you want to capture the expression itself — before R evaluates it.\nExample:\n\nmy_logger &lt;- function(expr) {\n  code &lt;- substitute(expr)\n  cat(\"You typed: \", deparse(code), \"\\n\")\n  val &lt;- eval(code)\n  val\n}\n\nHere, expr is just a placeholder. Without substitute(), R evaluates it before the function body runs, so the function can’t recover the original code.\nIf you’re writing a function where expr is already an expression (e.g., something like expr &lt;- quote(a + b) or expr &lt;- rlang::expr(a + b)), then you don’t want substitute() — because the expression is already captured.\nFor example:\n\ncode &lt;- quote(x + 1)\neval(code, envir = env)\n\n[1] 101\n\n\nHere, code is already a proper unevaluated call object — using substitute() on it would just return the symbol code, not the inner expression (similar to what happen when you use quote() inside a function)."
  },
  {
    "objectID": "posts/nse2/index.html#using-get-and-assign-for-controlled-evaluation",
    "href": "posts/nse2/index.html#using-get-and-assign-for-controlled-evaluation",
    "title": "Non-Standard Evaluation (NSE) for developers",
    "section": "3. Using get() and assign() for Controlled Evaluation",
    "text": "3. Using get() and assign() for Controlled Evaluation\nIn some cases, we don’t just want to evaluate expressions or capture what the user typed — we want to manipulate variables by name: retrieve their values from a particular environment, or assign new ones dynamically. That’s exactly what get() and assign() let us do.\nThese tools operate on variable names as strings, which makes them incredibly flexible — and also risky if not used carefully. In this section, we’ll break down both functions and show how they interact with environments and evaluation.\n\n3.1 get() — Look Up a Variable by Name\nThe base R function get() retrieves the value of a variable, given its name as a string, and optionally, an environment in which to look.\n\nx &lt;- 100\nget(\"x\")\n\n[1] 100\n\n\nIt’s equivalent to just writing x, but you can control where to search:\n\ne &lt;- rlang::env(x = 42)\nget(\"x\", envir = e)\n\n[1] 42\n\n\nIf x is not found, get() walks up the chain of parent environments, just like R’s normal variable resolution.\n\nget_and_print &lt;- function(name, env = parent.frame()) {\n  if (!exists(name, envir = env)) stop(\"Boo! it is not here\")\n  val &lt;- get(name, envir = env)\n  print(val)\n}\n\nenv2 &lt;- rlang::env(y = 2)\nx &lt;- 10\nget_and_print(\"x\") # 10\n\n[1] 10\n\nget_and_print(\"x\", env = env) # 100\n\n[1] 100\n\nget_and_print(\"x\", env = env2) # 10 again because of the env chain\n\n[1] 10\n\nget_and_print(\"zz\", env = env2) # error trigger by stop()\n\nError in get_and_print(\"zz\", env = env2): Boo! it is not here\n\n\n\nUse Case: Controlled Lookup in Logging\nSuppose you want to log both the name of the variable the user passed, and its value, without evaluating the entire expression. This is the same that we saw in the previous post with eval() but instead of having an expression, we have a the name of a variable.\n\nlog_value &lt;- function(varname) {\n  # Capture the name (unevaluated)\n  name &lt;- substitute(varname)\n\n  # Deparse to string\n  var_str &lt;- deparse(name)\n\n  # Lookup the value\n  value &lt;- get(var_str, envir = parent.frame())\n\n  cli::cli_inform(\"Variable {.code {var_str}} has value: {value}\")\n}\n\nscore &lt;- 88\nlog_value(score)\n\nVariable `score` has value: 88\n\n\nThis is cleaner and safer than passing varname directly (which would evaluate to the value before we can inspect it).\n\n\n\n3.2 assign() — Create or Modify a Variable by Name\nNow suppose you want to set a variable dynamically. assign() does the opposite of get() — it takes a name as a string and gives it a value:\n\nassign(\"z\", 999)\nz\n\n[1] 999\n\n\nYou can also specify the environment where the variable should be created or updated:\n\ne &lt;- rlang::env()\nassign(\"x\", 123, envir = e)\ne$x\n\n[1] 123\n\n\nThis is useful in programmatic pipelines, custom data transformations, or internal helpers where variable names are passed as arguments.\n\nExample: Dynamic Variable Creation in a Custom Environment\n\nset_and_show &lt;- function(name, value) {\n  name_str &lt;- deparse(substitute(name))\n  env &lt;- rlang::env()\n\n  assign(name_str, value, envir = env)\n  \n  # notice that we are extracting the value using `get()` not `value`\n\n  cli::cli_inform(\"Created {.code {name_str}} with value {.val {get(name_str, env)}}\")\n}\n\n\nset_and_show(score, 75)\n\nCreated `score` with value 75\n\n\nThis gives you total control over naming, assignment, and lookup — useful for package internals, simulations, or even domain-specific languages (DSLs).\n\n\n\nTo keep in mind\n\nget() and assign() allow for string-based variable manipulation.\nThey respect environments, which is critical for reproducibility and scoping.\nCombined with substitute(), you can safely bridge symbolic expressions and string-based evaluation.\nUse with care: dynamic variable manipulation can make code harder to debug.\n\n\n\n3.3 {rlang} Equivalents: env_get(), env_poke(), and Friends\nIf you’re writing packages or advanced tools, it’s usually better to avoid base R’s get() and assign() in favor of {rlang}’s environment manipulation functions, which are:\n\nexplicit about scoping\ntype-safe and testable\nand play nicely with modern metaprogramming idioms\n\n\nrlang::env_get(): Safer Alternative to get()\n\ne &lt;- rlang::env(x = 42)\nrlang::env_get(e, \"x\")\n\n[1] 42\n\n\nYou can also provide a default value if the variable is missing:\n\nrlang::env_get(e, \"y\")\n\nError in `rlang::env_get()`:\n! Can't find `y` in environment.\n\nrlang::env_get(e, \"y\", default = NA)\n\n[1] NA\n\n\nBy default, rlang::env_get() does not walk up the parent environments — unlike get(). If you want it to, use:\n\nget_and_print_rlang &lt;- function(name, \n                          env = parent.frame(), \n                          inherit = FALSE) {\n  if (!exists(name, envir = env)) stop(\"Boo! it is not here\")\n  val &lt;- rlang::env_get(env = env, \n                        nm = name, \n                        inherit = inherit)\n  print(val)\n}\n\nenv2 &lt;- rlang::env(y = 2)\nx &lt;- 10\nget_and_print(\"x\") # 10\n\n[1] 10\n\nget_and_print(\"x\", env = env) # 100\n\n[1] 100\n\nget_and_print(\"x\", env = env2) # 10 again because of the env chain\n\n[1] 10\n\nget_and_print_rlang(\"x\", env = env2) # error because it does not walk up\n\nError in `rlang::env_get()`:\n! Can't find `x` in environment.\n\nget_and_print_rlang(\"x\", env = env2, TRUE) # 10 again because of the env chain\n\n[1] 10\n\n\n\n\nrlang::env_poke(): Replacement for assign()\nenv_poke() sets a binding in an environment:\n\ne &lt;- rlang::env()\nrlang::env_poke(e, \"z\", 100)\ne$z\n\n[1] 100\n\n\nThis is clearer and more explicit than using assign() with a string.\n\n\nWhy Use {rlang} Instead of Base R?\n\n\n\n\n\n\n\n\n\nTask\nBase R\n{rlang}\nBenefit\n\n\n\n\nGet value\nget(\"x\", envir = e)\nenv_get(e, \"x\")\nNo surprises, inherits only if you want\n\n\nSet value\nassign(\"x\", val, envir = e)\nenv_poke(e, \"x\", val)\nCleaner and safer\n\n\nHas binding?\nexists(\"x\", envir = e)\nenv_has(e, \"x\")\nVectorized and clear\n\n\nRemove binding\nrm(\"x\", envir = e)\nenv_unbind(e, \"x\")\nSafer removal\n\n\n\n\n\nBonus: env_has() and env_unbind()\nWant to check if a variable exists?\n\nrlang::env_has(e, \"z\")\n\n   z \nTRUE \n\n\nRemove a variable:\n\nrlang::env_unbind(e, \"z\")\nrlang::env_has(e, \"z\")\n\n    z \nFALSE \n\n\n\n\nFinal Tip: Combine with substitute() or enquo()\nFor advanced use, you can combine env_get() with substitute() to convert a symbol to a string before lookup:\n\nget_value &lt;- function(x, .env = rlang::caller_env()) {\n  name &lt;- deparse(substitute(x))\n  rlang::env_get(.env, name)\n}\n\nfoo &lt;- 123\nget_value(foo)\n\n[1] 123\n\n\nThis is a safer, scoped version of get(\"foo\")."
  },
  {
    "objectID": "posts/nse2/index.html#data-masked-evaluation",
    "href": "posts/nse2/index.html#data-masked-evaluation",
    "title": "Non-Standard Evaluation (NSE) for developers",
    "section": "4. Data-Masked Evaluation",
    "text": "4. Data-Masked Evaluation\nWhen writing user-friendly R packages — especially those involving modeling, plotting, or data manipulation — it’s not enough to evaluate expressions in a custom environment. Often, you want to evaluate expressions as if columns of a data frame were variables, the way dplyr::filter() and ggplot2::aes() do it.\n\n4.1 What Is a Data Mask?\nA data mask is an environment that makes the columns of a data frame behave like variables. In practice, it means users can write expressions like mpg &gt; 25 instead of df$mpg &gt; 25, and your function will still understand what they meant.\nThe data mask lets you evaluate those expressions in a way that prioritizes the columns of the data frame while still allowing access to other objects from parent environments.\nThis is where data-masked evaluation comes in, and {rlang} provides the perfect tool for this: rlang::eval_tidy().\nBut first, we need to understand the difference between {rlang} and base B\n\nenquo() vs. substitute(): Tidy Capture vs. Base Capture\nIn base R, you use substitute(expr) to capture the unevaluated expression passed to a function. This gives you access to what the user typed, not the result of evaluation:\n\nlog_expr &lt;- function(expr) {\n  print(substitute(expr))\n}\nlog_expr(x + 1)\n\nx + 1\n\n#&gt; x + 1\n\nHowever, substitute() has no built-in way to capture quosures — expressions plus their environment. This is where rlang::enquo() comes in.\n\nlog_expr &lt;- function(expr) {\n  quo &lt;- rlang::enquo(expr)\n  print(quo)\n}\nlog_expr(x + 1)\n\n&lt;quosure&gt;\nexpr: ^x + 1\nenv:  global\n\n\n\nsubstitute() gives you a raw expression.\nrlang::enquo() gives you a quosure: an expression and the environment where it was typed.\n\nThis matters for tidy evaluation, where functions need to know not just what was written, but also where to evaluate it — especially if variables can be found in different environments.\n\n\neval_tidy() vs. eval(): Masked vs. Regular Evaluation\nIn base R, eval(expr, envir) evaluates expr using the provided environment envir. But that’s it — it treats envir as a regular environment.\nIn contrast, rlang::eval_tidy(expr, data) evaluates expr in a data mask, where:\n\nColumn names in data behave like variables.\nOuter variables (e.g., from global or calling environments) are still accessible if not masked by data columns.\n\n\nthreshold &lt;- 25\n\nrlang::eval_tidy(quote(mpg &gt; threshold), data = mtcars)\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[13] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n[25] FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n\n\nThis behaves as if both mpg and threshold were variables in the same environment. Internally, eval_tidy() creates a layered environment — first the data, then the calling environment — and evaluates expr inside that composite structure.\n\n\nBasic Example\nLet’s say we want to filter rows of a data frame using a custom function:\n\nmy_filter &lt;- function(data, expr) {\n  expr &lt;- rlang::enquo(expr)\n  rows &lt;- rlang::eval_tidy(expr, data)\n  data[rows, ]\n}\n\nThis lets you write:\n\nmy_filter(mtcars, mpg &gt; 25)\n\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n\n\nInside eval_tidy(), {rlang} creates a special environment where mpg is resolved to the column mtcars$mpg, not to any global variable. The masking happens safely and transparently.\n\n\n\nWhat If You Just Used eval()?\nTo emphasize the difference, try this:\n\nmy_filter_wrong &lt;- function(data, expr) {\n  expr &lt;- rlang::enquo(expr)\n  rows &lt;- eval(rlang::get_expr(expr))\n  data[rows, ]\n}\n\n# this fails\nmy_filter_wrong(mtcars, mpg &gt; 25)\n\nError in eval(rlang::get_expr(expr)): object 'mpg' not found\n\n\nWhy? Because eval() looks for mpg in the calling environment — not inside data. It has no idea that mpg is a column. This is the core problem eval_tidy() solves.\n\n\nYou Can Still Refer to Outer Variables\nThe power of eval_tidy() is that it doesn’t replace your environment — it augments it. You can still use objects from outside the data mask:\n\nthreshold &lt;- 100\n\nmy_filter(mtcars, hp &gt; threshold)\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n\nAs long as threshold exists in the parent environment, it will be found — but column names like hp will take priority.\nThis layered lookup structure makes your functions flexible and safe to use.\n\n\nWhy This Matters\n\neval_tidy() is the core of how packages like {ggplot2}, {dplyr}, {purrr} and {rlang} achieve their user-friendly syntax.\nIf you’re writing a function that evaluates expressions inside data frames, this is the right tool.\nUnlike eval(), it is safe, consistent, and scoped to your data."
  }
]