---
title: "Non-Standard Evaluation (NSE) for developers"
description: ""
author:
  - name: R.Andres Castaneda
    email: acastanedaa@worldbank.org
    affiliation: 
      - The World Bank
      - DECDG
date: "2025-05-09"
categories: [R, NSE, Metaprogramming]
format:
  html:
    toc: true
editor_options: 
  chunk_output_type: console
execute:
  output: true
---

## 1. Why NSE Matters for Developers

Non-Standard Evaluation (NSE) is not just a curiosity — it's a core part of modern R programming, especially for package developers who want to:

-   Build clean, expressive interfaces (like `dplyr::filter(mpg > 20)`)
-   Delay or relocate expression evaluation
-   Write tools for logging, debugging, or metaprogramming

To use NSE effectively, you need more than `quote()` or `substitute()`. You need tools that work *inside functions*, play well with environments, and support user-friendly interfaces. That’s where base tools like `get()` and modern tools from `{rlang}` come in.

## 2. Retrieving Variables from Custom Environments

Let’s start with something simple — but deceptive: using `get()` to evaluate code in a different environment.

### 2.1 The Basic Idea of `get()`

`get()` is a base R function that retrieves the **value bound to a name** from an environment. It's equivalent to doing `env$name`, but with more flexibility:

```{R}
env <- rlang::env(x = 100)
get("x", envir = env)
```

This looks simple. But it only works if you **already know the name** as a string.

If you try:

```{R}
#| error: true
var <- quote(x + 1)
get(var, envir = env)
```

You’ll get an error: `get()` doesn’t evaluate expressions — just single **symbols** (variable names). This limitation is why `get()` is only useful in very narrow NSE contexts.

### 2.2 Why `get()` Is Not Enough

Suppose you write a generic logging function like this:

```{R}
log_get <- function(var_name, env = parent.frame()) {
  value <- get(var_name, envir = env)
  cat("Found", var_name, "with value:", value, "\n")
}
```

It works:

```{R}
x <- 42
log_get("x")
```

But now try:

```{R}
#| error: true
log_get("x + 1")
```

This fails — because `"x + 1"` is not a symbol. It's a string that represents an expression, and `get()` can’t parse or evaluate it.

### 2.3 Using `eval()` Instead of `get()`

To evaluate **expressions**, we need `eval()`:

```{R}
env <- rlang::env(x = 100)
expr <- quote(x + 1)
eval(expr, envir = env)
```

This works because `eval()` knows how to process structured expressions (not just names) and can recursively resolve variables.

Now wrap this in a function:

```{R}
log_eval_expr <- function(expr, env = parent.frame()) {
  val <- eval(expr, envir = env)
  cat("Expression", deparse(expr), "evaluated to", val, "\n")
}

x <- 5
log_eval_expr(quote(x + 1))
```

**Takeaway**: Use `get()` when you have a **name**, use `eval()` when you have a **language object** (i.e., an expression).

### 2.4 What about `substitute()`

You may wonder why we are not using substitute in this function as we learned in the previous post? Good question. You need `substitute()` when you're writing a function that receives **user-typed code** (unevaluated), and you want to **capture the expression itself** — before R evaluates it.

Example:

```{r}
my_logger <- function(expr) {
  code <- substitute(expr)
  cat("You typed: ", deparse(code), "\n")
  val <- eval(code)
  val
}
```

Here, `expr` is just a placeholder. Without `substitute()`, R evaluates it **before** the function body runs, so the function can’t recover the original code.

If you're writing a function where `expr` is **already an expression** (e.g., something like `expr <- quote(a + b)` or `expr <- rlang::expr(a + b)`), then you don’t want `substitute()` — because the expression is already captured.

For example:

```{r}
code <- quote(x + 1)
eval(code, envir = env)
```

Here, `code` is already a proper unevaluated call object — using `substitute()` on it would just return the symbol `code`, not the inner expression (similar to what happen when you use `quote()` inside a function).

## 3. Using `get()` and `assign()` for Controlled Evaluation

In some cases, we don’t just want to evaluate expressions or capture what the user typed — we want to **manipulate variables by name**: retrieve their values from a particular environment, or assign new ones dynamically. That’s exactly what `get()` and `assign()` let us do.

These tools operate on variable *names as strings*, which makes them incredibly flexible — and also risky if not used carefully. In this section, we’ll break down both functions and show how they interact with environments and evaluation.

### 3.1 `get()` — Look Up a Variable by Name

The base R function `get()` retrieves the value of a variable, **given its name as a string**, and optionally, an environment in which to look.

```{R}
x <- 100
get("x")
```

It’s equivalent to just writing `x`, but you can control where to search:

```{R}
e <- rlang::env(x = 42)
get("x", envir = e)
```

If `x` is not found, `get()` walks up the chain of parent environments, just like R’s normal variable resolution.

```{R}
#| error: true
get_and_print <- function(name, env = parent.frame()) {
  if (!exists(name, envir = env)) stop("Boo! it is not here")
  val <- get(name, envir = env)
  print(val)
}

env2 <- rlang::env(y = 2)
x <- 10
get_and_print("x") # 10
get_and_print("x", env = env) # 100
get_and_print("x", env = env2) # 10 again because of the env chain
get_and_print("zz", env = env2) # error trigger by stop()
```

#### Use Case: Controlled Lookup in Logging

Suppose you want to log both the **name** of the variable the user passed, and its **value**, without evaluating the entire expression. This is the same that we saw in the previous post with `eval()` but instead of having an expression, we have a the name of a variable.

```{R}
log_value <- function(varname) {
  # Capture the name (unevaluated)
  name <- substitute(varname)

  # Deparse to string
  var_str <- deparse(name)

  # Lookup the value
  value <- get(var_str, envir = parent.frame())

  cli::cli_inform("Variable {.code {var_str}} has value: {value}")
}

score <- 88
log_value(score)
```

This is cleaner and safer than passing `varname` directly (which would evaluate to the value before we can inspect it).

### 3.2 `assign()` — Create or Modify a Variable by Name

Now suppose you want to set a variable dynamically. `assign()` does the opposite of `get()` — it takes a **name as a string** and gives it a value:

```{R}
assign("z", 999)
z
```

You can also specify the environment where the variable should be created or updated:

```{R}
e <- rlang::env()
assign("x", 123, envir = e)
e$x
```

This is useful in programmatic pipelines, custom data transformations, or internal helpers where variable names are passed as arguments.

#### Example: Dynamic Variable Creation in a Custom Environment

```{R}
set_and_show <- function(name, value) {
  name_str <- deparse(substitute(name))
  env <- rlang::env()

  assign(name_str, value, envir = env)
  
  # notice that we are extracting the value using `get()` not `value`

  cli::cli_inform("Created {.code {name_str}} with value {.val {get(name_str, env)}}")
}
```

```{R}
set_and_show(score, 75)
```

This gives you total control over naming, assignment, and lookup — useful for package internals, simulations, or even domain-specific languages (DSLs).

### To keep in mind

-   `get()` and `assign()` allow for **string-based variable manipulation**.
-   They respect **environments**, which is critical for reproducibility and scoping.
-   Combined with `substitute()`, you can safely bridge **symbolic expressions** and **string-based evaluation**.
-   Use with care: dynamic variable manipulation can make code harder to debug.

### 3.3 `{rlang}` Equivalents: `env_get()`, `env_poke()`, and Friends

If you’re writing packages or advanced tools, it’s usually better to avoid base R’s `get()` and `assign()` in favor of `{rlang}`'s **environment manipulation functions**, which are:

-   **explicit about scoping**
-   **type-safe and testable**
-   and **play nicely with modern metaprogramming idioms**

#### `rlang::env_get()`: Safer Alternative to `get()`

```{R}
e <- rlang::env(x = 42)
rlang::env_get(e, "x")
```

You can also provide a **default** value if the variable is missing:

```{R}
#| error: true
rlang::env_get(e, "y")

rlang::env_get(e, "y", default = NA)

```

By default, `rlang::env_get()` **does not walk up** the parent environments — unlike `get()`. If you want it to, use:

```{R}
#| error: true
get_and_print_rlang <- function(name, 
                          env = parent.frame(), 
                          inherit = FALSE) {
  if (!exists(name, envir = env)) stop("Boo! it is not here")
  val <- rlang::env_get(env = env, 
                        nm = name, 
                        inherit = inherit)
  print(val)
}

env2 <- rlang::env(y = 2)
x <- 10
get_and_print("x") # 10
get_and_print("x", env = env) # 100
get_and_print("x", env = env2) # 10 again because of the env chain
get_and_print_rlang("x", env = env2) # error because it does not walk up
get_and_print_rlang("x", env = env2, TRUE) # 10 again because of the env chain
```

#### `rlang::env_poke()`: Replacement for `assign()`

`env_poke()` sets a binding in an environment:

```{R}
e <- rlang::env()
rlang::env_poke(e, "z", 100)
e$z
```

This is clearer and more explicit than using `assign()` with a string.

#### Why Use `{rlang}` Instead of Base R?

| Task | Base R | `{rlang}` | Benefit |
|------------------|------------------|------------------|------------------|
| Get value | `get("x", envir = e)` | `env_get(e, "x")` | No surprises, inherits only if you want |
| Set value | `assign("x", val, envir = e)` | `env_poke(e, "x", val)` | Cleaner and safer |
| Has binding? | `exists("x", envir = e)` | `env_has(e, "x")` | Vectorized and clear |
| Remove binding | `rm("x", envir = e)` | `env_unbind(e, "x")` | Safer removal |

#### Bonus: `env_has()` and `env_unbind()`

Want to check if a variable exists?

```{R}
rlang::env_has(e, "z")
```

Remove a variable:

```{R}
rlang::env_unbind(e, "z")
rlang::env_has(e, "z")
```

#### Final Tip: Combine with `substitute()` or `enquo()`

For advanced use, you can combine `env_get()` with `substitute()` to convert a symbol to a string before lookup:

```{R}
get_value <- function(x, .env = rlang::caller_env()) {
  name <- deparse(substitute(x))
  rlang::env_get(.env, name)
}

foo <- 123
get_value(foo)
```

This is a safer, scoped version of `get("foo")`.

## 4. Data-Masked Evaluation

When writing user-friendly R packages — especially those involving modeling, plotting, or data manipulation — it’s not enough to evaluate expressions in a custom environment. Often, you want to evaluate expressions **as if columns of a data frame were variables**, the way `dplyr::filter()` and `ggplot2::aes()` do it.

### 4.1 What Is a Data Mask?

A **data mask** is an environment that makes the columns of a data frame behave like variables. In practice, it means users can write expressions like `mpg > 25` instead of `df$mpg > 25`, and your function will still understand what they meant.

The data mask lets you evaluate those expressions in a way that prioritizes the **columns of the data frame** while still allowing access to other objects from parent environments.

This is where **data-masked evaluation** comes in, and `{rlang}` provides the perfect tool for this: `rlang::eval_tidy()`.

But first, we need to understand the difference between `{rlang}` and `base R`

### 4.2 `enquo()` vs. `substitute()`: Tidy Capture vs. Base Capture

In base R, you use `substitute(expr)` to capture the unevaluated expression passed to a function. This gives you access to *what the user typed*, not the result of evaluation:

```{R}
log_expr <- function(expr) {
  print(substitute(expr))
}
log_expr(x + 1)
#> x + 1
```

However, `substitute()` has no built-in way to capture **quosures** — expressions *plus* their environment. This is where `rlang::enquo()` comes in.

```{R}
log_expr <- function(expr) {
  quo <- rlang::enquo(expr)
  print(quo)
}
log_expr(x + 1)
```

-   `substitute()` gives you a **raw expression**.
-   `rlang::enquo()` gives you a **quosure**: an expression *and* the environment where it was typed.

This matters for tidy evaluation, where functions need to know not just *what* was written, but also *where* to evaluate it — especially if variables can be found in different environments.


### 4.3 `eval_tidy()` vs. `eval()`: Masked vs. Regular Evaluation

In base R, `eval(expr, envir)` simply evaluates `expr` using the environment `envir` — no special treatment. But it can **fail** if the expression requires variables from *both* the data and the calling environment.

In contrast, `rlang::eval_tidy(expr, data, env)` evaluates `expr` in a **data mask**: a special layered environment where:

1. **Variable names** are looked up in `data` (e.g. column names or list elements),
2. If not found, the search continues in the **enclosing environment** — typically the environment where the function was called.

This allows expressions to blend **data variables** and **contextual variables** naturally — just like in `dplyr`, `ggplot2`, or `purrr`.

#### A Minimal Example

```{R}
data <- list(x = 1:5)
env  <- rlang::env(threshold = 3)

expr <- quote(x > threshold)
# This works: x from data, threshold from env
right <- rlang::eval_tidy(expr, data = data, env = env)


# This fails: base R's eval() only sees data, not env
wrong <- eval(expr, envir = data)

all.equal(right, wrong)
```

Here, `eval()` can’t see `threshold`, because it’s not in `data`. But `eval_tidy()` builds a layered environment where both `x` (from `data`) and `threshold` (from `env`) are visible.

#### Writing Functions: `eval_tidy()` Makes It Easy

Let’s say we want to write a filtering function that behaves like `dplyr::filter()` — letting users refer to columns *and* outside variables naturally.

```{R}
my_filter <- function(data, expr) {
  expr <- substitute(expr)
  rows <- rlang::eval_tidy(expr, data)
  data[rows, ]
}
```

Now this works:

```{R}
my_filter(mtcars, mpg > 25)

threshold <- 200
my_filter(mtcars, hp > threshold)
```


Inside `eval_tidy()`, `{rlang}` creates a **data mask** where:

* `mpg` is found in `data`, not in the global env.
* `threshold` is found in the parent frame (where the function was called).

This is the core mechanism that enables tidy evaluation to feel so natural.

#### What If You Just Used `eval()`?

To see why `eval()` isn’t enough, try this version:

```{R}
my_filter_wrong <- function(data, expr) {
  expr <- substitute(expr)
  rows <- eval(expr, envir = data)
  data[rows, ]
}
```

Now try:

```{R}
threshold <- 200
my_filter_wrong(mtcars, hp > threshold)
```

Why does this fail? Because `eval()` only looks in `data`, not in the calling environment — it doesn’t know where `threshold` lives.

### Why This Matters

* `rlang::eval_tidy()` builds a **layered lookup system**: first `data`, then the caller’s environment.
* This matches the mental model of users writing `filter(df, mpg > threshold)`.
* If you’re writing functions for data manipulation, modeling, or interactive tools, `eval_tidy()` gives you **safe, powerful, and consistent** control over evaluation.
* Base R’s `eval()` is great for evaluating code in a single environment — but it lacks the nuance that tidy evaluation provides.
