---
title: "Non-Standard Evaluation (NSE) for developers"
description: ""
author:
  - name: R.Andres Castaneda
    email: acastanedaa@worldbank.org
    affiliation: 
      - The World Bank
      - DECDG
date: "2025-05-09"
categories: [R, NSE, Metaprogramming]
format:
  html:
    toc: true
editor_options: 
  chunk_output_type: console
execute:
  output: true
---


## 1. Why NSE Matters for Developers

Non-Standard Evaluation (NSE) is not just a curiosity — it's a core part of modern R programming, especially for package developers who want to:

* Build clean, expressive interfaces (like `dplyr::filter(mpg > 20)`)
* Delay or relocate expression evaluation
* Write tools for logging, debugging, or metaprogramming

To use NSE effectively, you need more than `quote()` or `substitute()`. You need tools that work *inside functions*, play well with environments, and support user-friendly interfaces. That’s where base tools like `get()` and modern tools from `{rlang}` come in.


## 2. Retrieving Variables from Custom Environments

Let’s start with something simple — but deceptive: using `get()` to evaluate code in a different environment.

### 2.1 The Basic Idea of `get()`

`get()` is a base R function that retrieves the **value bound to a name** from an environment. It's equivalent to doing `env$name`, but with more flexibility:

```{R}
env <- rlang::env(x = 100)
get("x", envir = env)
```

This looks simple. But it only works if you **already know the name** as a string.

If you try:

```{R}
#| error: true
var <- quote(x + 1)
get(var, envir = env)
```

You’ll get an error: `get()` doesn’t evaluate expressions — just single **symbols** (variable names). This limitation is why `get()` is only useful in very narrow NSE contexts.



### 2.2 Why `get()` Is Not Enough

Suppose you write a generic logging function like this:

```{R}
log_get <- function(var_name, env = parent.frame()) {
  value <- get(var_name, envir = env)
  cat("Found", var_name, "with value:", value, "\n")
}
```

It works:

```{R}
x <- 42
log_get("x")
```

But now try:

```{R}
#| error: true
log_get("x + 1")
```

This fails — because `"x + 1"` is not a symbol. It's a string that represents an expression, and `get()` can’t parse or evaluate it.


### 2.3 Using `eval()` Instead of `get()`

To evaluate **expressions**, we need `eval()`:

```{R}
env <- rlang::env(x = 100)
expr <- quote(x + 1)
eval(expr, envir = env)
```

This works because `eval()` knows how to process structured expressions (not just names) and can recursively resolve variables.

Now wrap this in a function:

```{R}
log_eval_expr <- function(expr, env = parent.frame()) {
  val <- eval(expr, envir = env)
  cat("Expression", deparse(expr), "evaluated to", val, "\n")
}

x <- 5
log_eval_expr(quote(x + 1))
```

**Takeaway**: Use `get()` when you have a **name**, use `eval()` when you have a **language object** (i.e., an expression).



### 2.4 What about `substitute()`

You may wonder why we are not using substitute in this function as we learned in the previous post? Good question.  You need `substitute()` when you're writing a function that receives **user-typed code** (unevaluated), and you want to **capture the expression itself** — before R evaluates it.

Example:

```{r}
my_logger <- function(expr) {
  code <- substitute(expr)
  cat("You typed: ", deparse(code), "\n")
  val <- eval(code)
  val
}
```

Here, `expr` is just a placeholder. Without `substitute()`, R evaluates it **before** the function body runs, so the function can’t recover the original code.


If you're writing a function where `expr` is **already an expression** (e.g., something like `expr <- quote(a + b)` or `expr <- rlang::expr(a + b)`), then you don’t want `substitute()` — because the expression is already captured.

For example:

```{r}
code <- quote(x + 1)
eval(code, envir = env)
```

Here, `code` is already a proper unevaluated call object — using `substitute()` on it would just return the symbol `code`, not the inner expression (similar to what happen when you use `quote()` inside a function).

## 3. Using `get()` and `assign()` for Controlled Evaluation

In some cases, we don’t just want to evaluate expressions or capture what the user typed — we want to **manipulate variables by name**: retrieve their values from a particular environment, or assign new ones dynamically. That’s exactly what `get()` and `assign()` let us do.

These tools operate on variable *names as strings*, which makes them incredibly flexible — and also risky if not used carefully. In this section, we’ll break down both functions and show how they interact with environments and evaluation.

### 3.1 `get()` — Look Up a Variable by Name

The base R function `get()` retrieves the value of a variable, **given its name as a string**, and optionally, an environment in which to look.

```{R}
x <- 100
get("x")
```

It’s equivalent to just writing `x`, but you can control where to search:

```{R}
e <- rlang::env(x = 42)
get("x", envir = e)
```

If `x` is not found, `get()` walks up the chain of parent environments, just like R’s normal variable resolution.


```{R}
#| error: true
get_and_print <- function(name, env = parent.frame()) {
  if (!exists(name, envir = env)) stop("Boo! it is not here")
  val <- get(name, envir = env)
  print(val)
}

env2 <- rlang::env(y = 2)
x <- 10
get_and_print("x") # 10
get_and_print("x", env = env) # 100
get_and_print("x", env = env2) # 10 again because of the env chain
get_and_print("zz", env = env2) # error trigger by stop()
```


#### Use Case: Controlled Lookup in Logging

Suppose you want to log both the **name** of the variable the user passed, and its **value**, without evaluating the entire expression. This is the same that we saw in the previous post with `eval()` but instead of having an expression, we have a the name of a variable. 

```{R}
log_value <- function(varname) {
  # Capture the name (unevaluated)
  name <- substitute(varname)

  # Deparse to string
  var_str <- deparse(name)

  # Lookup the value
  value <- get(var_str, envir = parent.frame())

  cli::cli_inform("Variable {.code {var_str}} has value: {value}")
}

score <- 88
log_value(score)
```

This is cleaner and safer than passing `varname` directly (which would evaluate to the value before we can inspect it).

### 3.2 `assign()` — Create or Modify a Variable by Name

Now suppose you want to set a variable dynamically. `assign()` does the opposite of `get()` — it takes a **name as a string** and gives it a value:

```{R}
assign("z", 999)
z
```

You can also specify the environment where the variable should be created or updated:

```{R}
e <- rlang::env()
assign("x", 123, envir = e)
e$x
```

This is useful in programmatic pipelines, custom data transformations, or internal helpers where variable names are passed as arguments.


#### Example: Dynamic Variable Creation in a Custom Environment

```{R}
set_and_show <- function(name, value) {
  name_str <- deparse(substitute(name))
  env <- rlang::env()

  assign(name_str, value, envir = env)
  
  # notice that we are extracting the value using `get()` not `value`

  cli::cli_inform("Created {.code {name_str}} with value {.val {get(name_str, env)}}")
}
```

```{R}
set_and_show(score, 75)
```

This gives you total control over naming, assignment, and lookup — useful for package internals, simulations, or even domain-specific languages (DSLs).


### To keep in mind

* `get()` and `assign()` allow for **string-based variable manipulation**.
* They respect **environments**, which is critical for reproducibility and scoping.
* Combined with `substitute()`, you can safely bridge **symbolic expressions** and **string-based evaluation**.
* Use with care: dynamic variable manipulation can make code harder to debug.


### 3.3 `{rlang}` Equivalents: `env_get()`, `env_poke()`, and Friends

If you’re writing packages or advanced tools, it’s usually better to avoid base R’s `get()` and `assign()` in favor of `{rlang}`'s **environment manipulation functions**, which are:

* **explicit about scoping**
* **type-safe and testable**
* and **play nicely with modern metaprogramming idioms**


#### `rlang::env_get()`: Safer Alternative to `get()`

```{R}
e <- rlang::env(x = 42)
rlang::env_get(e, "x")
```

You can also provide a **default** value if the variable is missing:

```{R}
#| error: true
rlang::env_get(e, "y")

rlang::env_get(e, "y", default = NA)

```

By default, `rlang::env_get()` **does not walk up** the parent environments — unlike `get()`. If you want it to, use:

```{R}
#| error: true
get_and_print_rlang <- function(name, 
                          env = parent.frame(), 
                          inherit = FALSE) {
  if (!exists(name, envir = env)) stop("Boo! it is not here")
  val <- rlang::env_get(env = env, 
                        nm = name, 
                        inherit = inherit)
  print(val)
}

env2 <- rlang::env(y = 2)
x <- 10
get_and_print("x") # 10
get_and_print("x", env = env) # 100
get_and_print("x", env = env2) # 10 again because of the env chain
get_and_print_rlang("x", env = env2) # error because it does not walk up
get_and_print_rlang("x", env = env2, TRUE) # 10 again because of the env chain
```


#### `rlang::env_poke()`: Replacement for `assign()`

`env_poke()` sets a binding in an environment:

```{R}
e <- rlang::env()
rlang::env_poke(e, "z", 100)
e$z
```

This is clearer and more explicit than using `assign()` with a string.


#### Why Use `{rlang}` Instead of Base R?

| Task           | Base R                        | `{rlang}`               | Benefit                                 |
| -------------- | ----------------------------- | ----------------------- | --------------------------------------- |
| Get value      | `get("x", envir = e)`         | `env_get(e, "x")`       | No surprises, inherits only if you want |
| Set value      | `assign("x", val, envir = e)` | `env_poke(e, "x", val)` | Cleaner and safer                       |
| Has binding?   | `exists("x", envir = e)`      | `env_has(e, "x")`       | Vectorized and clear                    |
| Remove binding | `rm("x", envir = e)`          | `env_unbind(e, "x")`    | Safer removal                           |


#### Bonus: `env_has()` and `env_unbind()`

Want to check if a variable exists?

```{R}
rlang::env_has(e, "z")
```

Remove a variable:

```{R}
rlang::env_unbind(e, "z")
rlang::env_has(e, "z")
```


#### Final Tip: Combine with `substitute()` or `enquo()`

For advanced use, you can combine `env_get()` with `substitute()` to convert a symbol to a string before lookup:

```{R}
get_value <- function(x, .env = rlang::caller_env()) {
  name <- deparse(substitute(x))
  rlang::env_get(.env, name)
}

foo <- 123
get_value(foo)
```

This is a safer, scoped version of `get("foo")`.


## 4. Data-Masked Evaluation

When writing user-friendly R packages — especially those involving modeling, plotting, or data manipulation — it’s not enough to evaluate expressions in a custom environment. Often, you want to evaluate expressions **as if columns of a data frame were variables**, the way `dplyr::filter()` and `ggplot2::aes()` do it.


### 4.1 What Is a Data Mask?

A **data mask** is an environment that makes the columns of a data frame behave like variables. In practice, it means users can write expressions like `mpg > 25` instead of `df$mpg > 25`, and your function will still understand what they meant.

The data mask lets you evaluate those expressions in a way that prioritizes the **columns of the data frame** while still allowing access to other objects from parent environments.

This is where **data-masked evaluation** comes in, and `{rlang}` provides the perfect tool for this: `rlang::eval_tidy()`.

But first, we need to understand the difference between `{rlang}` and `base B`

#### `enquo()` vs. `substitute()`: Tidy Capture vs. Base Capture

In base R, you use `substitute(expr)` to capture the unevaluated expression passed to a function. This gives you access to *what the user typed*, not the result of evaluation:

```{R}
log_expr <- function(expr) {
  print(substitute(expr))
}
log_expr(x + 1)
#> x + 1
```

However, `substitute()` has no built-in way to capture **quosures** — expressions *plus* their environment. This is where `rlang::enquo()` comes in.

```{R}
log_expr <- function(expr) {
  quo <- rlang::enquo(expr)
  print(quo)
}
log_expr(x + 1)
```

* `substitute()` gives you a **raw expression**.
* `rlang::enquo()` gives you a **quosure**: an expression *and* the environment where it was typed.

This matters for tidy evaluation, where functions need to know not just *what* was written, but also *where* to evaluate it — especially if variables can be found in different environments.

#### `eval_tidy()` vs. `eval()`: Masked vs. Regular Evaluation

In base R, `eval(expr, envir)` evaluates `expr` using the provided environment `envir`. But that’s it — it treats `envir` as a regular environment.

In contrast, `rlang::eval_tidy(expr, data)` evaluates `expr` in a **data mask**, where:

1. Column names in `data` behave like variables.
2. Outer variables (e.g., from global or calling environments) are still accessible if not masked by data columns.

```{R}
threshold <- 25

rlang::eval_tidy(quote(mpg > threshold), data = mtcars)
```

This behaves as if both `mpg` and `threshold` were variables in the same environment. Internally, `eval_tidy()` creates a **layered environment** — first the data, then the calling environment — and evaluates `expr` inside that composite structure.



#### Basic Example

Let’s say we want to filter rows of a data frame using a custom function:

```{R}

my_filter <- function(data, expr) {
  expr <- rlang::enquo(expr)
  rows <- rlang::eval_tidy(expr, data)
  data[rows, ]
}
```

This lets you write:

```{R}
my_filter(mtcars, mpg > 25)
```

Inside `eval_tidy()`, `{rlang}` creates a special environment where `mpg` is resolved to the column `mtcars$mpg`, not to any global variable. The masking happens safely and transparently.

### What If You Just Used `eval()`?

To emphasize the difference, try this:

```{R}
#| error: true 
my_filter_wrong <- function(data, expr) {
  expr <- rlang::enquo(expr)
  rows <- eval(rlang::get_expr(expr))
  data[rows, ]
}

# this fails
my_filter_wrong(mtcars, mpg > 25)
```


Why? Because `eval()` looks for `mpg` in the calling environment — not inside `data`. It has no idea that `mpg` is a column. This is the core problem `eval_tidy()` solves.

### You Can Still Refer to Outer Variables

The power of `eval_tidy()` is that it doesn’t *replace* your environment — it *augments* it. You can still use objects from outside the data mask:

```{R}
threshold <- 100

my_filter(mtcars, hp > threshold)
```

As long as `threshold` exists in the parent environment, it will be found — but column names like `hp` will take priority.

This layered lookup structure makes your functions flexible and safe to use.

### Why This Matters

* `eval_tidy()` is the core of how packages like `{ggplot2}`, `{dplyr}`, `{purrr}` and `{rlang}` achieve their user-friendly syntax.
* If you’re writing a function that evaluates expressions inside data frames, this is the right tool.
* Unlike `eval()`, it is **safe**, **consistent**, and **scoped** to your data.

