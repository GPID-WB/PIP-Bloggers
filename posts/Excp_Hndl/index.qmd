---
title: "Mastering tryCatch() in R: From Basics to Structured Logging"
description: "Learn how to use tryCatch() in R to handle errors and warnings, recover from failures, and build structured logging systems."
author: "Diana C. Garcia"
date: "2025-02-13"
categories: [R, Error Handling, Robust Code]
format:
  html:
    toc: true
editor_options: 
  chunk_output_type: console
execute:
  output: true
---

## Introduction

Error handling is a fundamental part of writing reliable R code. Whether you’re reading dozens of files, running a loop over thousands of observations, or building a data pipeline, something is bound to go wrong. When it does, `tryCatch()` allows your code to fail gracefully—without crashing your entire process.

In this post, we’ll start from scratch to understand how `tryCatch()` works, and build up to a practical and structured approach to logging and recovering from specific types of failures. Our goal is not just to catch errors, but to catch them **with context**, and handle them in a **controlled and traceable** way.


## 1. A First Look at `tryCatch()`

Let’s begin with a minimal example that handles a simple error:

```{r}
tryCatch(
  expr = {
    stop("Something went wrong!")
  },
  error = function(e) {
    message("Caught an error: ", e$message)
    return(NA)
  }
)
```

This code tries to run the expression `stop("...")`, which throws an error. The `error =` block intercepts that error and prints a message, returning `NA` instead.

Similarly, we can catch warnings:

```{r}
tryCatch(
  expr = {
    warning("Something is off...")
    42
  },
  warning = function(w) {
    message("Caught a warning: ", w$message)
    return(-1)
  }
)
```

And we can also define a `finally` block that always runs, even if there's no error or warning:

```{r}
tryCatch(
  expr = {
    10
  },
  finally = {
    message("This always runs.")
  }
)
```

The core idea is this: `tryCatch()` lets you write error-handling logic in the same place your code runs, using specific condition types (like `error`, `warning`, or custom classes).


## 2. A Practical Example with Recovery Logic

Let’s look at a more realistic scenario. Suppose you have a function that sometimes succeeds, sometimes warns, and sometimes fails, depending on the input. 

:::{.callout-note}
This example is an adaptation of Jonathanscallahan's blog [Basic Error Handing in R with tryCatch()](https://www.r-bloggers.com/2020/10/basic-error-handing-in-r-with-trycatch/)
:::


```{r}
my_divide <- function(d, a) {
  if (a == "warning") {
    warning("my_divide warning message")
    return("Warning fallback result")
  } else if (a == "error") {
    stop("my_divide error message")
  } else {
    return(d / as.numeric(a))
  }
}
```

Now let’s use `tryCatch()` to run this function and react to each case:

```{r}
run_example <- function(a) {
  result <- tryCatch({

    b <- 2
    c <- b^2
    d <- c + 2

    if (a == "suppress-warnings") {
      e <- suppressWarnings(my_divide(d, a))
    } else {
      e <- my_divide(d, a)
    }

    f <- e + 100
    f

  }, warning = function(w) {
    message("Caught warning: ", conditionMessage(w))
    e <- my_divide(d, 0.1)
    f <- e + 100
    return(f)

  }, error = function(e) {
    message("Caught error: ", conditionMessage(e))
    e <- my_divide(d, 0.01)
    f <- e + 100
    return(f)

  }, finally = {
    message("a = ", a, "| b = ", b, "| c = ", c, "| d = ", d)
  })

  message("Final result: ", result)
  return(result)
}
```

Try it with different arguments:

```{r}
run_example("warning")
run_example("error")
run_example("2")
run_example("suppress-warnings")
```

This function shows several important ideas:

- You can distinguish between warnings and errors.
- You can recover differently depending on what went wrong.
- The `finally` block executes even if an error occurred.
- Values returned from the handler become the return value of the entire `tryCatch()` block.
