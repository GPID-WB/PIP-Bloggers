---
title: "Exception Handling"
description: "Using tryCatch() within PIP"
author: "Diana C. Garcia"
date: "02/13/2025"
categories: [Errors, Warnings]
---

The following is an example of how to use exception handling in R within the PIP pipeline. In particular, I focus on using `tryCatch` . This is a simplifies example from what we used on the cleaning process in `pipdata`.

## Load libraries and functions

First, these are the main libraries needed.

```{r}
#| warning: false
# Load libraries 
library(metapip) 
library(data.table)
library(pipload)
```

However, make sure to have installed the following packages as well: `cli` and `rlang` .

The following is the example of the function we need to be "handle" with `tryCatch`. This function tries to check if there are duplicates in `dt` according to some `keyVar` and if there are duplicates it can abort and exit or continue without exiting and logging the error. The function has another two parameters to decide the following:

1.  `log_err` if we want the error to be included in a error-report log.

2.  `skip_err` if we want the error to be skipped or not.

```{r}
# Function to handle duplicated observations in pfw 
unq_pfw <- function(dt,
                    keyVar,
                    log_err = TRUE,
                    skip_err = TRUE){   
  tryCatch(      
    expr = {        
      if(uniqueN(dt, by = keyVar) != nrow(dt)){          
        dt_d <- dt[duplicated(dt, by = keyVar)]         
        n_rep <- nrow(dt_d)          
        cli::cli_abort(message = "There {?is/are} {n_rep} duplicates in `pfw`",
                       class = c("dup_pfw", "piperr"),
                       log = log_err,
                       skip = skip_err,
                       link =  unique(dt_d$link),
                       call = sys.call())       
        }      
      },      
    dup_pfw = function(cnd){        
      if(cnd$log){ 
        # Log the error          
        add_log(cnd)        
      }        
      if(!cnd$skip){ 
        # Abort if you don't want to skip, but after logging          
        cli::cli_abort(cnd$message, call = cnd$call)        
      }
      },
    error = function(cnd){
      # Abort for unknown error
      cli::cli_abort("Unknown Error", call = cnd$call)
    },      
    finally = {        
      dt <- unique(dt, by = keyVar) # eliminate duplicates      
    }    
  )   
  
  return(dt) 
  
  }
```

If you run the lines within `expr ={ }`, this will probably crash and an error about duplicates will be shown. However, **what we want is to first record this error on a log, and then decide if to skip the error or not, and get a clean dataset**. Also, if there was another error within `expr ={ }`, the function will not log the error, it will stop the process and warn of an "Unknown Error". That is why we need `tryCatch`. As you can see within the `finally` section, we also included a line that eliminates the duplicates and returns the new "clean" data set.

This is how `tryCatch` works in our example: First, within the parameters of `cli::cli_abort()`, `message` works as expected. However, `class` might be the most important to describe. The class we give to this specific error, or condition, will be what makes it identifiable on our `tryCatch`. Since we gave a new `class` to the error called `dup_pfw`, the function `tryCatch`, instead of aborting and exiting the code when the error is found, will run the code within `dup_pfw = function(cnd){ }` instead. The parameter `cnd` then carries all the information we gave within `cil::cli_abort`; the `class`, the `log/skip` actions, and the identifiers of the duplicates called `link` .

**Important:** The parameters `log` and `skip` within `cil::cli_abort` are the tools we use to handle this error and these are totally made up for this specific function. You can create any parameter you want within `cli::abort()` and this will carry on within the handler. For example, the parameter `link` will carry the identifiers of those duplicated observations, which are needed for the error-report log.

Regarding the log, before running the code below, we need to load the following function `add_log`. This function will load some concatenated text on the file `log.txt` saved in the working directory and it is used within the handler.

```{r}
# Function for logging 
add_log <- function(cnd) {    
  cat("[", class(cnd)[[1]], "-", class(cnd)[[2]], "] ",     
      cnd$message," for ",     
      cnd$link, "\n", sep = "",     
      file = "log.txt", append = TRUE)  
  }
```

## Load data and run code

The data we will use for this example can be loaded with `pipload` and represents the auxiliary Price Frame Work, or `pfw`. Since we need to run over the error at some point, we have to create another data frame with some duplicates, `pfw_d` .

```{r}
#| warning: true

# Load data 
pfw_t <- pip_load_aux("pfw")  
pfw_d <- rbind(pfw_t, pfw_t[rep(1, 5), ]) # Duplicate some rows from one country
```

Now, we will run the function and this should not give any errors because the default value is `skip_err = TRUE` .

```{r}
# Run tryCatch for unq_pwf function 
keyVar <- c("country_code", "surveyid_year", "survey_acronym")  
pfw <- unq_pfw(pfw_d, keyVar)
```

If the error was handled and skipped correctly, according to the default parameters, the answer to the following code should give you `TRUE` and you will find a `log.txt` file with the new record of these error.

```{r}
# Test  
uniqueN(pfw, by = keyVar) == nrow(pfw)
```

However, if you run the function without skipping the error, the abort function will come into action:

```{r}
#| error: true

# Run tryCatch for unq_pwf function without skipping error  
pfw <- unq_pfw(pfw_d, keyVar, skip_err = FALSE)
```

```{r}
#| echo: false

unlink("log.txt")
```

## Sources

A few websites I reviewed to learned more about this:

1.  <https://adv-r.hadley.nz/conditions.html#conditions>
2.  <https://medium.com/number-around-us/catch-me-if-you-can-exception-handling-in-r-2e0f6c473a28>
3.  <https://cnuge.github.io/post/trycatch/>
4.  <https://aryoda.github.io/tutorials/tryCatchLog/tryCatchLog-intro-slides.html#/> (still reviewing it)

## 
