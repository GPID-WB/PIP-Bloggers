---
title: "What Is Non-Standard Evaluation (NSE) and Why Does It Matter?"
description: ""
author:
  - name: R.Andres Castaneda
    email: acastanedaa@worldbank.org
    affiliation: 
      - The World Bank
      - DECDG
date: "2025-04-17"
categories: [R, NSE, Metaprogramming]
format:
  html:
    toc: true
editor_options: 
  chunk_output_type: console
execute:
  output: true
---


## 1. Intro

Non-Standard Evaluation (NSE) is one of the most powerful — and most confusing — features of the R language. It allows functions to manipulate the **expressions** that users write, instead of just their evaluated values. This behavior is at the heart of many modeling and data manipulation tools in R, including `with()`, `subset()`, and all of the tidyverse.



### Historical Roots: `with()` and `subset()` in Base R

Before packages like `dplyr`, base R already offered functions that evaluated expressions **in a different context** — usually within a data frame — without requiring users to quote variable names.

Here are two classic examples:

```{R}
with(mtcars, mpg + cyl)
#> Adds mpg and cyl from mtcars — no $ needed

subset(mtcars, mpg > 20)
#> Filters rows where mpg > 20 — again, mpg is unquoted
```

In both cases, you are allowed to write expressions like `mpg + cyl` or `mpg > 20` directly, without using `mtcars$mpg`. This works because `with()` and `subset()` don't evaluate their arguments immediately. Instead, they capture the **expression** you wrote and evaluate it **inside the data frame environment**.

This ability to manipulate expressions and control where they are evaluated is exactly what Non-Standard Evaluation enables.



### What Is Standard Evaluation?

To appreciate what NSE changes, it helps to understand what R does **by default** — which is standard evaluation (SE).

In SE, R evaluates every name and expression **before** passing it to a function. For example:

```{R}
x <- 10
f <- function(y) y + 1
f(x)
```

Here, `x` is evaluated to `10`, and `f()` receives that value.

### What Is Non-Standard Evaluation?

With NSE, a function can capture **what the user typed** — the unevaluated expression — and decide:

- **When** to evaluate it,
- **Where** to evaluate it,
- Or even whether to evaluate it at all.

Let’s create a minimal example:

```{R}
print_expr <- function(expr) {
  print(expr)
}
print_expr(x + 1)
```

Looks standard, right? Now try this:

```{R}
print_expr <- function(expr) {
  print(substitute(expr))
}
print_expr(x + 1)
```

Now we’re seeing the **expression** `x + 1` itself, rather than the result `11`. That’s NSE in action: we intercepted the unevaluated code.

### A Concrete Example: Logging

Let’s write a simple logger that prints the code you typed:

```{R}
log_eval <- function(expr) {
  cat("About to evaluate:", deparse(substitute(expr)), "\n")
  result <- eval(expr)
  result
}

x <- 2
log_eval(x + 3)
```

This function:

- Uses `substitute()` to capture the expression `x + 3`,
- Prints the expression,
- Then evaluates it.


## 2. Expressions Are Not Strings: Understanding How R Represents Code

To understand that piece of code fully, we need to know five into tools like `substitute()`, `deparse()`, or `eval()`. Yet, there is something even more fundamental to  understand first:

> In R, **code is data**.

When you write `x + 1`, R does **not** treat that as text or as a string. Instead, it creates a structured object — an **expression** — that the interpreter can inspect, manipulate, or evaluate later.

This idea is essential to understanding how Non-Standard Evaluation (NSE) works.

### What Is an Expression?

In R, an **expression** is an object that represents unevaluated code.

Here’s how you create one:

```{R}
expr <- quote(x + 1)
expr
```

This object is **not** the result of `x + 1`, and it’s not the character string `"x + 1"` (notice that it does not have quotes in the console). It’s a special object of class `"call"` — sometimes also called a **language object**.

You can verify this:

```{R}
class(expr)
typeof(expr)
```

This means that R has captured the code itself — as structured, evaluable (i.e., unevaluated) data.

### Why Expressions Are Not Strings

Try this:

```{R}
expr <- quote(x + 1)
is.character(expr)
print(expr)
```

Even though it *looks like* a string when printed, it's not. R stores the structure of the code, not its textual representation.

In fact, expressions behave like recursive lists. You can inspect their components:

```{R}
expr[[1]]  # the function being called
expr[[2]]  # first argument
expr[[3]]  # second argument
```

This kind of structure is what makes metaprogramming possible in R.

### `quote()` – The Basic Tool to Capture Code

`quote()` is the most direct way to create an expression.

```{R}
quote(mean(x, na.rm = TRUE))
```

This returns a `"call"` object, which you can store, inspect, and evaluate later.

`quote()` prevents R from evaluating the expression. It captures it *as is*, before any names are resolved.

Compare:

```{R}
x <- 10
quote(x + 1)
x + 1
```

In the first case, R captures the expression; in the second, it evaluates it.

### `deparse()` – Turning Code into Strings

Now suppose you want to print this expression. If you use `print(expr)`, you get a nice display. But if you need the **actual string** `"x + 1"` (e.g. for logging or incluting it in `cat()` or `paste()`), you need `deparse()`:

```{R}
expr <- quote(x + 1)
deparse(expr)
```

So:

- `quote(x + 1)` → structured expression
- `deparse(quote(x + 1))` → character string `"x + 1"`

This distinction is critical. If you treat expressions like strings too early, you lose their structure.


### `substitute()` – Capturing Expressions from Arguments

While `quote()` is explicit, `substitute()` works *implicitly* by intercepting **what the user typed as an argument**.

Example:

```{R}
log_expr <- function(arg) {
  code <- substitute(arg)
  print(code)
}

log_expr(x + 1)
```

Behind the scenes, `substitute(arg)` is doing the same thing as `quote(x + 1)` — except it’s happening **within the calling context**. That’s why we often say that `substitute()` is a dynamic version of `quote()` — it’s context-sensitive.

To show the equivalence:

```{R}
quote(x + 1) == substitute(x + 1)
```

But `substitute(arg)` only works inside a function — because it inspects the actual expression passed to `arg`.


### So, What's the differen between  `quote()` and `substitute()`?

Although both `quote()` and `substitute()` capture unevaluated expressions, they are **not the same**, and understanding when they diverge is critical for writing correct NSE-aware code.

#### Example: Inside a Function

```{R}
expr_catcher <- function(arg) {
  cat("substitute(arg):", deparse(substitute(arg)), "\n")
  cat("quote(arg):     ", deparse(quote(arg)), "\n")
}
```

```{R}
x <- 10
expr_catcher(x + 1)
```


- `substitute(arg)` inspects the **expression passed to `arg`**, and returns it: `x + 1`.
- `quote(arg)` simply returns the symbol `arg` — it doesn’t know what was passed in the call.

####  When to Use Each

| Use case                            | Use `quote()`             | Use `substitute()`         |
|-------------------------------------|----------------------------|-----------------------------|
| Capture a static expression         | ✅ Yes                    | ❌ No                       |
| Capture what the user typed in a function | ❌ No                    | ✅ Yes                      |
| Manual metaprogramming or testing   | ✅ Yes                    | Sometimes (but trickier)    |
| Logging or error messages inside functions | ❌ No                 | ✅ Yes                      |



### Outside a Function (They Behave the Same)

```{R}
quote(x + 1)
substitute(x + 1)
```


- Using `quote()` inside a function will **not** show what the user typed — it just gives you the name of the argument.
- If you're writing logging wrappers, DSLs, or tidy-eval-like interfaces, `substitute()` is what gives you access to the **real input**.


### Putting It All Together

Let’s summarize the roles:

| Function        | Purpose                                   | Returns                |
|------------------|--------------------------------------------|------------------------|
| `quote(expr)`   | Capture unevaluated code                   | Expression / call      |
| `substitute(arg)`| Capture the *argument* passed to a function | Expression / call      |
| `deparse(expr)` | Convert an expression to a string          | Character string       |
| `eval(expr)`    | Evaluate the expression                    | Result of computation  |

They often appear together:

```{R}
x <- 2

inspect <- function(expr) {
  code <- substitute(expr)
  cat("You typed: ", deparse(code), "\n")
  result <- eval(code)
  cat("It evaluated to: ", result, "\n")
}

inspect(x + 3)
```


## Why This Matters

- R expressions are **not text** — they are structured data objects.
- NSE works by capturing and delaying evaluation of these expressions.
- `quote()` and `substitute()` give you control over *what* is captured.
- `deparse()` turns code into readable strings for logging, reporting, or messages.
- `eval()` executes code only when and where you want.

Understanding how R stores and manipulates expressions is the first step to mastering metaprogramming, the tidy evaluation framework, and robust logging or transformation pipelines.

