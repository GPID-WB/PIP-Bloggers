---
title: "R Environments Demystified (Part 1): Foundations of Environments and the Evaluation Stack"
description: "Understand the core structure of environments in R, the difference between frames and environments, and how functions capture and navigate them."
author:
  - name: R.Andres Castaneda
    email: acastanedaa@worldbank.org
    affiliation: 
      - The World Bank
      - DECDG
  - name: Zander Prinsloo
    email: zprinsloo@worldbank.org
date: "2025-04-17"
categories: [R, Environments, Metaprogramming]
format:
  html:
    toc: true
editor_options: 
  chunk_output_type: console
execute:
  output: true
---

## Intro

In this post — the first in a three-part series — we go from **basic concepts** of environments and scoping to more advanced ideas like **frames**, **call stacks**, and how environments interact with function evaluation.

We’ll introduce the `{rlang}` package early on and use it as our main toolkit, referring to base R only when necessary. All `rlang` calls are explicitly prefixed (e.g., `rlang::env_parent()`) to make their source clear.

## 1. What Is an Environment?

Environments are one of the most fundamental and misunderstood structures in R. Everything that happens in R — from evaluating a simple expression to calling a function — happens **in an environment**. Understanding them is essential for grasping how R evaluates code, tracks variables, and structures memory.

An environment is a special kind of object in R that acts like a **named container** — a collection of variable bindings — with a very important twist: each environment has a **parent**.

You can think of an environment as:

-   A set of name-value pairs (like a dictionary),
-   With a reference to another environment (its parent),
-   Forming a **chain** of environments that R uses to look up names.

At a high level, environments answer the question:\
\> “When I type a name, where should R look to find its value?”

### Creating Environments

You can create new environments in base R using `new.env()`, but we will primarily use `{rlang}`’s more expressive tools. For instance, `rlang::env()` allows you to bind names at creation:

```{R}
env1 <- rlang::env(x = 1, y = "text", z = TRUE)
rlang::env_print(env1)
```

You’ve just created an environment `env1` with three bindings (`x`, `y`, `z`), and its parent is the **global environment** by default.

You can access individual values using `rlang::env_get()`:

```{R}
rlang::env_get(env1, "x")
```

You can add or update values:

```{R}
rlang::env_bind(env1, y = "updated")
rlang::env_get(env1, "y")
```

And remove values:

```{R}
#| error: true
rlang::env_unbind(env1, "z")
rlang::env_get(env1, "z") # <- This gives you an error
```

### Special Environments

```{R}
#| eval: false

rlang::global_env()   # Your top-level workspace
rlang::base_env()     # The environment of base R functions
rlang::empty_env()    # The bottom of the chain (no parent)
```

### chain of enviromments

Let's crate an environment inside another

```{R}
# Define env1 as a child of global environment
env1 <- rlang::env(a = 1)

# Define env2 as a child of env1. According to the manual: You can supply one
# unnamed argument to specify a custom parent, otherwise it defaults to the
# current environment
env2 <- rlang::env(env1, x = "child")
```

You can traverse this chain using `rlang::env_parent()` and `rlang::env_parents()`:

```{r}
identical(rlang::env_parent(env2), env1)
identical(rlang::env_parent(env1), rlang::global_env())

# this is FALSE
identical(rlang::env_parent(rlang::global_env()), rlang::empty_env())

# Notice all the parents of the GlobaL env 
rlang::env_parents(rlang::global_env())

```

### Environments Are Not Lists

While environments and lists can both hold named elements, they are **very different**:

```{R}
my_list <- list(a = 1, b = 2)
my_env  <- rlang::env(a = 1, b = 2)
```

Key differences:

<!-- https://getbootstrap.com/docs/5.3/utilities/colors/ -->
<!-- https://unhcr-dataviz.github.io/quarto-html-unhcr/ -->
:::{.border .border-danger}
[Zander:]{.text-danger} Please add your table with the differences
:::


Try this:

```{R}
my_env$b <- 99
my_list$b <- 99

print(my_env$b)   # Direct reference — no copy
print(my_list$b)  # Modified copy — not shared
```

This difference matters when we use environments to build persistent memory (as in closures) or pass values between layers of code.

### Why This Matters

Environments aren’t just another container — they’re the **backbone of how R works**:

-   Every function runs in an environment.
-   Every object name is resolved by walking up an environment chain.
-   Environments define **lexical scoping**, which controls what variables are visible and from where.
-   Unlike lists, environments are **never copied on modification**, making them ideal for caching, memoization, and shared mutable state.

In short, if you don’t understand environments, you’ll always be fighting R’s evaluation model.

In the next section, we’ll explore how **environments are connected**, how names are resolved across parents, and how to **walk the environment chain**.
